<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Apue | ApprEngineer.log]]></title>
  <link href="http://kentaktwo.github.com/blog/categories/apue/atom.xml" rel="self"/>
  <link href="http://kentaktwo.github.com/"/>
  <updated>2015-01-24T23:42:45+09:00</updated>
  <id>http://kentaktwo.github.com/</id>
  <author>
    <name><![CDATA[kentaktwo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Advanced Programming in the UNIX Environment Chapter 5]]></title>
    <link href="http://kentaktwo.github.com/blog/2013/01/18/apue-chapter-5/"/>
    <updated>2013-01-18T21:10:00+09:00</updated>
    <id>http://kentaktwo.github.com/blog/2013/01/18/apue-chapter-5</id>
    <content type="html"><![CDATA[<h1>Standard I/O Library</h1>

<!--more-->


<h2>Stream</h2>

<ul>
<li>システムコールでの I/O は file descriptor を使用していた。</li>
<li>standard I/O library では、<em>stream</em> と呼ばれるものを使用する。</li>
<li>stream は single-byte, multibyte (&ldquo;wide&rdquo;) 両方の文字セットで使用できる。</li>
<li>read や write を single-byte か multibyte どちらで行うかを決めるものを stream&rsquo;s orientation と呼ぶ。</li>
<li><code>fwide()</code> 関数で stream&rsquo;s orientation を変更することができる。</li>
</ul>


<h2>FILE Object</h2>

<ul>
<li><code>fopen()</code> などで stream を open すると、<code>FILE</code> オブジェクトのポインタが返ってくる。</li>
<li><code>FILE</code> には standard I/O library が stream を扱うのに必要な情報が入っている。</li>
<li><code>FILE *</code> を file pointer と呼ぶ。</li>
</ul>


<h2>Standard Input, Standard Output, and Standard Error</h2>

<p><code>STDIN_FILENO</code>, <code>STDOUT_FILENO</code>, <code>STDERR_FILENO</code> file descriptor に対応する file pointer として、
<code>stdin</code>, <code>stdout</code>, <code>stderr</code> が <code>&lt;stdio.h&gt;</code> で定義されている。</p>

<h2>Buffering</h2>

<p>standard I/O library は <code>read()</code> や <code>write()</code> の呼び出し回数をできるだけ少なくするために、
buffering を行なっている。3種類の buffering が提供されている:</p>

<ol>
<li>Fully buffered: 実際の I/O は buffer がいっぱいになったときに実行される。<br/>
ディスクの読み込みなどは fully buffered である。</li>
<li>Line buffered: input や output で改行記号を検出したときに I/O が行われる。<br/>
stdin や stdout などのターミナル関連での buffering は Line buffered である。</li>
<li>Unbuffered: buffering しない。<br/>
standard error stream などは Unbuffered である (すぐに表示してほしいため)。</li>
</ol>


<!--dummy comment line for breaking list-->


<ul>
<li>buffering は <code>setbuf()</code> や <code>setvbuf()</code> で変更することができる。</li>
<li>standard I/O buffer の中身を書きだすことを <em>flush</em> と呼ぶ。

<ul>
<li>flush は buffer がいっぱいになったときなどに standard I/O が自動的に行なってくれるが、
<code>fflush()</code> を呼ぶことで明示的に行うこともできる。</li>
</ul>
</li>
</ul>


<h2>Opening a Stream</h2>

<pre><code class="c">FILE *fopen(const char *restrict pathname, const char *restrict type);
FILE *freopen(const char *restrict pathname, const char *restrict type, FILE *restrict fp);
FILE *fdopen(int filedes, const char *restrict type);

return file pointer if OK, NULL on error
</code></pre>

<ul>
<li><code>fopen()</code> はファイル名を指定して open する。</li>
<li><code>freopen()</code> はファイル名を指定して、指定した stream に open する。

<ul>
<li>stdin, stdout, stderr などに open したい場合に使う。</li>
</ul>
</li>
<li><code>fdopen()</code> は file descriptor を指定して open する。</li>
<li><em>type</em> は

<ul>
<li><code>r</code> はそのまま、<code>w</code> は truncate する、<code>a</code> は追記する</li>
<li><code>+</code> をつけると read, write 両方になる</li>
<li><code>fdopen()</code> の場合、既にファイルが open されているため、truncate は行われない。</li>
</ul>
</li>
</ul>


<h2>Closing a Stream</h2>

<ul>
<li>open stream を close するには <code>fclose()</code> を使う。</li>
<li>buffering された output data は close される前に flush される。</li>
<li>buffering された input data は破棄される。</li>
<li>standard I/O library が自動的に確保した buffer は解放される。</li>
<li><code>exit()</code> が呼ばれると自動的に <code>close()</code> される。</li>
</ul>


<h2>Reading and Writing a Stream</h2>

<p>unformatted I/O を行う関数には、3種類ある。</p>

<h3>Character-at-a-time I/O</h3>

<p>文字単位で入出力する。</p>

<pre><code class="c">#include &lt;stdio.h&gt;

/* Input Functions */
int getc(FILE *fp);
int fgetc(FILE *fp);
int getchar(void);

return next character if OK, EOF on end of file or error

/* Output Functions */
int putc(int c, FILE *fp);
int fputc(int c, FILE *fp);
int putchar(int c);

return c if OK, EOF on error
</code></pre>

<ul>
<li><code>getchar()</code> は <code>getc(stdin)</code> と同じ</li>
<li><code>getc()</code> はマクロの場合があるが、<code>fgetc()</code> は必ず関数である</li>
<li><code>EOF</code> は多くの場合 -1 として定義される</li>
</ul>


<p><code>EOF</code> が返ってきたときに、EOF なのかエラーなのかわからないため、それを判別する関数が用意されている。</p>

<pre><code class="c">#include &lt;stdio.h&gt;

int ferror(FILE *fp);
int feof(FILE *fp);

return nonzero if condition is true, 0 otherwise
</code></pre>

<ul>
<li>FILE Object の中で、error flag や end-of-file flag が管理されている。</li>
<li><code>clearerr()</code> でそれらの flag をクリアできる。</li>
</ul>


<p><code>ungetc()</code> で1文字読み戻すことができる。</p>

<pre><code class="c">#include &lt;stdio.h&gt;

int ungetc(int c, FILE *fp);

return c if OK, EOF on error
</code></pre>

<ul>
<li>読み戻せるのは1文字まで</li>
</ul>


<h3>Line-at-a-time I/O</h3>

<pre><code class="c">#include &lt;stdio.h&gt;

char *fgets(char *restrict buf, int n, FILE *restrict fp);
char *gets(char *buf);

return buf if OK, NULL on end of file or error
</code></pre>

<ul>
<li>改行記号に達するか、<em>n - 1</em> byte まで読み込む (最後に null byte を入れるため)</li>
<li><code>gets()</code> は buffer size を指定できないため、使ってはいけない</li>
</ul>


<pre><code>#include &lt;stdio.h&gt;

int fputs(const char *restrict str, FILE *restrict fp);
int puts(const char *str);

return non-negative value if OK, EOF on error
</code></pre>

<ul>
<li>null byte まで書きだす (null byte は書き出されない)</li>
<li>改行記号が入っている必要はない</li>
<li><code>puts()</code> に <code>gets()</code> のような脆弱性は無いが、使わない方がいいだろう</li>
</ul>


<h3>Binary I/O</h3>

<pre><code class="c">#include &lt;stdio.h&gt;

size_t fread(void *restrict ptr, size_t size, size_t nobj, FILE *restrict fp);
size_t fwrite(const void *restrict ptr, size_t size, size_t nobj, FILE *restrict fp);

return number of objects read or written
</code></pre>

<ul>
<li>1単位あたりのサイズを <em>size</em> で指定して、読み書きする単位数を <em>nobj</em> で指定する

<ul>
<li><em>size</em> は <code>sizeof(float)</code> や構造体のサイズなど</li>
</ul>
</li>
<li>バイナリや、構造体を読み書きするのに使う

<ul>
<li>システムによってデータ構造が違ったりするので、異なるシステム間ではうまく動作しない</li>
</ul>
</li>
</ul>


<h2>Standard I/O Efficiency</h2>

<ul>
<li>システムコールを呼ぶのが一番コストがかかる</li>
<li>standard I/O を使うと、システムコールを呼ぶ回数を減らすように buffering してくれるので、
直接システムコールを呼ぶより高速になることが多い

<ul>
<li>効率良くなるように自分でシステムコールを呼ぶ調整をしている場合は別</li>
</ul>
</li>
</ul>


<h2>Positioning a Stream</h2>

<p>standard I/O stream の位置を調べる関数は3種類ある:
1. <code>ftell()</code>, <code>fseek()</code>: 位置は <code>long</code> で表す
2. <code>ftello()</code>, <code>fseeko()</code>: <code>ftell()</code> と <code>fseek()</code> の <code>long</code> が <code>off_t</code> に置き換わったもの
3. <code>fgetpos()</code>, fsetpos()<code>:</code>fpos_t` を使って位置を表す。UNIX でないシステムではこれを使う</p>

<h2>Formatted I/O</h2>

<h3>Formatted Output</h3>

<pre><code class="c">#include &lt;stdio.h&gt;

int printf(const char *restrict format, ...);
int fprintf(FILE *restrict fp, const char *restrict format, ...);

return number of characters output if OK, nagative value if output error

int sprintf(char *restrict buf, const char *restrict format, ...);
int snprintf(char *restrict buf, size_t n, const char *restrict format, ...);

return number of characters stored in array if OK, negative value if encoding error
</code></pre>

<ul>
<li><code>sprintf()</code> はオーバーフローする恐れがあるので、<code>snprintf()</code> を使うこと。</li>
<li>% 記号で始まるやつ (conversion specification) のフォーマットは以下の通り</li>
</ul>


<pre><code class="c">%[flags][fldwidth][precision][lenmodifier]convtype
</code></pre>

<ul>
<li>&ldquo;&hellip;&rdquo; の代わりに、<code>va_list</code> になった <code>vprintf()</code> 系の関数もある (<code>&lt;stdarg.h&gt;</code> を includeする)。</li>
</ul>


<h3>Formatted Input</h3>

<pre><code class="c">#include &lt;stdio.h&gt;
int scanf(const char *restrict format, ...);
int fscanf(FILE *restrict fp, const char *restrict format, ...);
int sscanf(const char *restrict buf, const char *restrict format, ...);

return number of input items assigned, EOF if input error or end of file before any conversion
</code></pre>

<ul>
<li>conversion specification のフォーマットは以下の通り</li>
</ul>


<pre><code class="c">%[*][fldwidth][lenmodifier]convtype
</code></pre>

<ul>
<li>頭にアスタリスクがついているやつについては conversion 結果が変数に格納されない</li>
<li>&ldquo;&hellip;&rdquo; の代わりに、<code>va_list</code> になった <code>vscanf()</code> 系の関数もある (<code>&lt;stdarg.h&gt;</code> を includeする)。</li>
</ul>


<h2>Implementation Details</h2>

<ul>
<li><code>fileno()</code> 関数で file pointer に対応する file descriptor が取得できる。</li>
</ul>


<h2>Temporary Files</h2>

<pre><code class="c">#include &lt;stdio.h&gt;

char *tmpnam(char *ptr);
returns pointer to unique pathname

FILE *tmpfile(void);
returns file pointer if OK, NULL on error
</code></pre>

<ul>
<li><code>tmpnam()</code> は存在しているファイル名とかぶらないパス名を作成する。

<ul>
<li>最大 <code>TMP_MAX</code> 回は異なるパス名が生成される (<code>TMP_MAX</code> は <code>&lt;stdio.h&gt;</code> で定義されている)。</li>
<li><em>ptr</em> が <code>NULL</code> の場合、作られたパス名は static area に格納される。</li>
<li><em>ptr</em> が <code>NULL</code> でない場合、その参照先の buffer は少なくとも
<code>L_tmpnam</code> 以上のサイズがある必要がある (<code>L_tmpnam</code> は <code>&lt;stdio.h&gt;</code> で定義されている)。</li>
</ul>
</li>
<li><code>tmpfile()</code> は type が <code>wb+</code> の一時ファイルを作成する。これはプログラム終了時に削除される。</li>
</ul>


<p>以下の2つの関数が XSI で定義されている</p>

<pre><code class="c">#include &lt;stdio.h&gt;
char *tempnam(const char *directory, const char *prefix);
returns pointer to unique pathname

#include &lt;stdio.h&gt;
int mkstemp(char *template);
returns file descriptor if OK, -1 on error
</code></pre>

<ul>
<li><code>tempnam()</code> はディレクトリとプレフィックスが指定できる <code>tmpnam()</code> である。

<ul>
<li><em>directory</em> は環境変数 <code>TMP_DIR</code> が最優先される。
<code>TMP_DIR</code> が参照するディレクトリが存在しない場合、スキップされる。</li>
<li><em>directory</em> が <code>NULL</code> の場合、<code>P_tmpdir</code> が使われる。</li>
<li><em>prefix</em> にはファイル名の先頭を最大5文字まで指定することができる。</li>
</ul>
</li>
<li><code>mkstemp()</code> は一時ファイルを作るが、file pointer の代わりに file descriptor を返す。

<ul>
<li><em>template</em> には、最後が <code>XXXXXX</code> で終わるような文字列を渡す。そこにユニークな文字が入る。</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Advanced Programming in the UNIX Enviroment Chapter 4]]></title>
    <link href="http://kentaktwo.github.com/blog/2012/10/14/apue-chapter-4/"/>
    <updated>2012-10-14T14:25:00+09:00</updated>
    <id>http://kentaktwo.github.com/blog/2012/10/14/apue-chapter-4</id>
    <content type="html"><![CDATA[<h1>Files and Directories</h1>

<!--more-->


<h2>stat, fstat and lstat Functions</h2>

<pre><code class="c">#include &lt;sys/stat.h&gt;
int stat(const char *restrict pathname, struct stat *restrict buf);
int fstat(int filedes, struct stat *buf);
int lstat(const char *restrict pathname, struct stat *restrict buf);

return 0 if OK, -1 on error
</code></pre>

<ul>
<li>ファイルについての情報が書かれた構造体 (stat 構造体) を返す。

<ul>
<li><code>stat()</code> はファイル名</li>
<li><code>fstat()</code> はファイルディスクリプタ</li>
<li><code>lstat()</code> はシンボリックリンク
(<code>stat()</code> の場合はシンボリックリンクのときはその参照先)</li>
</ul>
</li>
<li>restrict ポインタはそのポインタが別名を持たないことを保証し、
コンパイル時の最適化を効率的に行うことができる。</li>
<li>stat 構造体の定義は実装によるが、だいたい以下のようになる</li>
</ul>


<pre><code class="c">struct stat {
    mode_t      st_mode;    /* file type &amp; mode (permissions) */
    ino_t       st_ino;     /* i-node number (serial number) */
    dev_t       st_dev;     /* device number (file system) */
    dev_t       st_rdev;    /* device number for special files */
    nlink_t     st_nlink;   /* number of links */
    uid_t       st_uid;     /* user ID of owner */
    gid_t       st_gid;     /* group ID of owner */
    off_t       st_size;    /* size in bytes, for regular files */
    time_t      st_atime;   /* time of last access */
    time_t      st_mtime;   /* time of last modification */
    time_t      st_ctime;   /* time of last file status change */
    blksize_t   st_blksize; /* best I/O block size */
    blkcnt_t    st_blocks;  /* number of disk blocks allocated */
};
</code></pre>

<h2>File Types</h2>

<ul>
<li>ファイルの種類は7種類

<ul>
<li>Regular file</li>
<li>Directory file</li>
<li>Block special file: ディスクドライブなどのデバイスに buffered I/O アクセスする</li>
<li>Character special file: デバイスに unbuffered I/O アクセスする</li>
<li>FIFO: プロセス間通信で使う。pipe とも呼ばれる。</li>
<li>Socket: プロセス間のネットワーク通信に使う。</li>
<li>Symbolic link: 他のファイルを参照するファイル</li>
</ul>
</li>
<li>ファイルの種類は <code>st_mode</code> に入っている。</li>
<li>ファイルの種類を調べるには <code>S_ISREG()</code>, <code>S_ISDIR()</code> などのマクロを使う。

<ul>
<li>Linux で <code>S_ISSOCK()</code> マクロを使うには <code>_GNU_SOURCE</code> を定義する必要がある。</li>
</ul>
</li>
</ul>


<h2>Set-User-ID and Set-Group-ID</h2>

<ul>
<li>すべてのプロセスは関連する ID を持っている

<ul>
<li>real user ID, real group ID<br/>
自分が誰なのかを表す。login 時に password file から読み取られる。</li>
<li>effective user ID, effective group ID, supplementary group ID<br/>
ファイルアクセスの権限を表す。</li>
<li>saved set-user-ID, saved set-group-ID<br/>
プログラム実行時の effective user ID と effective group ID のコピー</li>
</ul>
</li>
<li>プログラムが実行されると、通常 effective user (group) ID には real user (group) ID がセットされるが、
<em>set-user-ID</em> bit や <em>set-group-ID</em> bit を立てると、
effective user (group) ID をそのファイルのオーナー (<code>st_uid</code>, <code>st_gid</code>) にすることができる。

<ul>
<li><code>passwd(1)</code> はスーパーユーザーで実行される必要がある。</li>
</ul>
</li>
<li>set-user-ID (set-group-ID) bit は<code>st_mode</code> の中に含まれ、<code>S_ISUID()</code>, <code>S_ISGID()</code> で調べることができる。</li>
</ul>


<h2>File Access Permissions</h2>

<ul>
<li>directory の execute 権限は search bit とも呼ばれる

<ul>
<li>directory の read 権限は directory 内のファイル名のリストを表示したりする (directory file を読む) 権限</li>
<li>directory の execute 権限は directory にアクセスする権限</li>
</ul>
</li>
<li>ファイルを削除するには、そのファイルがある directory に write と execute 権限があることが必要。
そのファイル自体に read や write 権限がある必要はない。</li>
<li>owner ID はファイルのプロパティであり、effective ID はプロセスのプロパティである。</li>
</ul>


<h2>access Function</h2>

<pre><code class="c">#include &lt;unistd.h&gt;
int access(const char *pathname, int mode);

return 0 if OK, -1 on error
</code></pre>

<ul>
<li>(effective でなく) real user (group) ID がファイルへの権限を持っているか調べる。</li>
<li>set-user-ID されていても、real user ID についての権限が調べられる。</li>
</ul>


<h2>umask Function</h2>

<pre><code class="c">#include &lt;sys/stat.h&gt;
mode_t umask(mode_t cmask);

return: 変更前の mask
</code></pre>

<ul>
<li>ファイル作成時に umask に設定した権限を除外することができる。

<ul>
<li><code>S_IROTH | S_IWOTH</code> みたいにして設定</li>
</ul>
</li>
<li>プログラム内で設定した umask はプログラムが終了すると元に戻る。</li>
</ul>


<h2>chmod and fchmod Functions</h2>

<pre><code class="c">#include &lt;sys/stat.h&gt;
int chmod(const char *pathname, mode_t mode);
int fchmod(int filedes, mode_t mode);

return 0 if OK, -1 on error
</code></pre>

<ul>
<li>ファイルのアクセス権限を変更する。</li>
<li>現在の権限から group execute 権限を取り除き、set-group-ID するには</li>
</ul>


<pre><code class="c">struct stat statbuf;
stat("foo", &amp;statbuf);
chmod("foo", (statbuf.st_mode &amp; ~S_IXGRP) | S_ISGID);
</code></pre>

<ul>
<li><code>ls -l</code> したときに execute 権限にある <code>S</code> は execute 権限は無いが、
set-user-ID (set-group-ID) されてるという意味。</li>
</ul>


<h2>Sticky Bit</h2>

<ul>
<li>sticky bit がセットされたプログラムが実行されると、
プロセス終了時にそのコピーがスワップ領域にコピーされる。</li>
<li>次回以降そのプログラム実行時のメモリへのロードが高速になる。</li>
<li>sticky bit をセットにするには <code>S_ISVTX</code> をセットする。</li>
<li>最近の UNIX システムでは <em>saved-text</em> bit と呼ばれる。</li>
<li>最近の UNIX システムでは Virtual memory システムだったり、ファイルシステムが高速
になったりで、このテクニックの必要は薄くなっている。</li>
<li>最近は sticky bit は directory にセットされる使い方をしている。

<ul>
<li>directory に sticky bit がセットされると、directory 内のファイルは
directory への write 権限を持っていて、かつ

<ul>
<li>ファイルのオーナーである</li>
<li>ディレクトリのオーナーである</li>
<li>スーパーユーザーである
のいずれかを満たすユーザにしか消去や名前の変更ができないようになる。</li>
</ul>
</li>
<li>sticky bit がセットされている directory には、<code>/tmp</code> などがある。

<ul>
<li><code>/tmp</code> には色んなユーザがファイルを作成するので、
パーミッションは 777 になっているが、sticky bit がセットされているので、
ファイルの削除などはオーナーにしかできない。</li>
</ul>
</li>
</ul>
</li>
</ul>


<h2>chown, fchown, and lchown Functions</h2>

<ul>
<li><code>chown()</code> でファイルの user ID や group ID を変更することができる。</li>
</ul>


<pre><code class="c">#include &lt;unistd.h&gt;
int chown(const char *pathname, uid_t owner, gid_t group);
int fchown(int filedes, uid_t owner, gid_t group);
int lchown(const char *pathname, uid_t owner, gid_t group);

return 0 if OK, -1 on error
</code></pre>

<ul>
<li><code>lchown()</code> はシンボリックリンク自体のオーナーを変更する</li>
<li><em>owner</em> または <em>group</em> を -1 にすると、その ID は変更されない</li>
<li><code>_POSIX_CHOWN_RESTRICTED</code> が有効になっていると、他のユーザのファイルの user ID は変更できない。
自分のファイルの group ID は変更できるが、自分が所属しているグループにしか変更できない。</li>
<li>superuser のプロセスからこれらの関数が実行されると、set-user-ID と set-group-ID の bit はクリアされる</li>
</ul>


<h2>File Size</h2>

<ul>
<li><code>stat</code> 構造体の <code>st_size</code> にはファイルのサイズがバイト単位で入っている</li>
<li>このフィールドは regular files, directories, symbolic links のときのみ意味をなす

<ul>
<li>regular file の場合、ファイルサイズ 0 が許容される。これはファイルの最初が end-of-file の場合である。</li>
<li>directory の場合、ファイルサイズは 16 や 512 などの複数の値になる。</li>
<li>symbolic link の場合、ファイルサイズはリンク先のファイル名の長さ (byte) になる。
例えば、リンク先が &ldquo;usr/lib&rdquo; のとき、ファイルサイズは 7 になる。</li>
</ul>
</li>
<li>最近の UNIX システムでは、<code>st_blksize</code> と <code>st_blocks</code> というフィールドも用意されている

<ul>
<li><code>st_blksize</code> はファイル I/O の望ましいブロックサイズ</li>
<li><code>st_blocks</code> は割り当てられた 512-byte ブロックの数</li>
<li>standard I/O library では、効率化のため、1回に <code>st_blksize</code> の分だけ read や write を行う</li>
</ul>
</li>
</ul>


<h2>File Truncation</h2>

<pre><code class="c">#include &lt;unistd.h&gt;
int truncate(const char *pathname, off_t length);
int ftruncate(int filedes, off_t length);

return 0 if OK, -1 on error
</code></pre>

<ul>
<li>ファイルの長さを <em>length</em> バイトに切り詰める</li>
<li>truncate 前のファイルサイズが <em>length</em> より大きい場合、<em>length</em> より後ろのデータにはアクセスできなくなる</li>
<li>truncate 前のファイルサイズが <em>length</em> より小さい場合、どうなるかは実装依存だが、
XSI-conforming system の場合、ファイルサイズは大きくなる (hole ができる)</li>
</ul>


<h2>File Systems</h2>

<h3>Hard Links</h3>

<ul>
<li>各 i-node は link count を持っている。これは自身の i-node を参照しているディレクトリの数である。</li>
<li>link count が 0 になったときのみ、このファイルは削除することができる。

<ul>
<li>ディレクトリのエントリを削除する関数が delete でなく unlink なのはそのため。</li>
</ul>
</li>
<li>link count は <code>stat</code> 構造体の中の <code>st_nlink</code> メンバに格納されている。この型は <code>nlink_t</code> 型である。</li>
<li>link count の最大値は <code>LINK_MAX</code> で定義されている。</li>
</ul>


<h3>Symbolic Links</h3>

<ul>
<li>symbolic link の指す data block の中にはこのリンクが参照するファイル名が書かれている。</li>
<li>この i-node には file type に <code>S_IFLNK</code> がセットされている。</li>
</ul>


<h3>Directory</h3>

<ul>
<li>directory entry には ファイル名や i-node 番号などが書かれている。</li>
<li>i-node 番号の型は <code>ino_t</code> 型である。</li>
<li>directory entry に書かれた i-node 番号は同じファイルシステム上のものであり、
別のファイルシステムの i-node を参照することはできない。
<code>ln(1)</code> コマンドをファイルシステムをまたがって叩くことができないのはそのためである。</li>
<li><code>mv(1)</code> は directory entry を変更しているだけで、実際のファイルの中身が変更されているわけではない。</li>
<li>leaf directory (他の directory を含んでいない directory) の link count は常に2となる (<code>.</code> と親ディレクトリからの参照)</li>
<li>leaf directory でない directory の link count は 3 以上となる (<code>.</code>, 子ディレクトリの <code>..</code>, 親ディレクトリからの参照)</li>
</ul>


<h2>link, unlink, remove, and rename Functions</h2>

<pre><code class="c">#include &lt;unistd.h&gt;
int link(cont char *existingpath, const char *newpath);
int unlink(const char *pathname);

return 0 if OK, -1 on error
</code></pre>

<ul>
<li><code>link()</code> は <em>existingpath</em> を参照する新しい directory entry を <em>newpath</em> に作成する。

<ul>
<li><em>newpath</em> がすでに存在する場合はエラーとなる。</li>
<li>POSIX.1 はファイルシステムをまたいで link することを許しているが、
ほとんどの実装ではそれぞれのパスは同じファイルシステム上になくてはならない。</li>
<li>directory の hard link を作成できる実装の場合、それができるのは superuser に限られる。

<ul>
<li>loop が発生する恐れがあるため。</li>
<li>多くのファイルシステムの実装では directory の hard link を作ることを許可していない。</li>
</ul>
</li>
</ul>
</li>
<li><p><code>unlink()</code> は directory entry を削除し、 link count を減らす。</p>

<ul>
<li>link count が 0 になったときのみ、このファイルの中身を削除することができるが、
ファイルが open されているときはまだ削除できない。

<ul>
<li>ファイルが close されたときに、kernel がそのファイルを open しているプロセス数をチェックする。
それが 0 なら、次に link count をチェックし、それも 0 ならファイルの中身を削除する。</li>
</ul>
</li>
<li><em>pathname</em> が symbolic link の場合、<code>unlink()</code> は参照先ではなく、symbolic link 自体を削除する。</li>
</ul>
</li>
<li><p>superuser は <code>unlink()</code> に directory を指定することもできるが、それよりも <code>rmdir()</code> を使うべきである。</p></li>
<li>file と directory 両方に使える関数に <code>remove()</code> がある。</li>
</ul>


<pre><code class="c">#include &lt;stdio.h&gt;
int remove(const char *pathname);

return 0 if OK, -1 on error
</code></pre>

<ul>
<li><p><code>remove()</code> は対象が file なら <code>unlink()</code> と同じであり、directory なら <code>rmdir()</code> と同じである。</p></li>
<li><p>file や directory は <code>rename()</code> で名前を変えることができる。</p></li>
</ul>


<pre><code class="c">#include &lt;stdio.h&gt;
int rename(const char *oldname, const char *newname);

return 0 if OK, -1 on error
</code></pre>

<ul>
<li><em>newname</em> が既に存在していた場合、<em>newname</em> は削除され、<em>oldname</em> が <em>newname</em> に rename される。

<ul>
<li>directory の場合、<em>newname</em> は空である必要がある。</li>
</ul>
</li>
<li>symbolic link の場合、参照先ではなく、リンク自身が rename される。</li>
<li><em>oldname</em> と <em>newname</em> が同じ場合、変更されずに、0 が返る。</li>
</ul>


<h2>Symbolic Links</h2>

<ul>
<li>symbolic link は i-node を直接参照する hard link とは違い、間接的にファイルを参照する。</li>
<li>symbolic link はファイルシステムをまたぐことに関する制限はない。</li>
<li>directory を指す symbolic link を作る際にも root 権限は必要ない。</li>
<li>ファイル名でファイルを参照する関数には、symbolic link をたどり参照先のファイルを見るものと、
たどらずに、symbolic link 自体を見るものがある。

<ul>
<li><code>chown()</code> がどちらになるかは実装による</li>
<li><code>open()</code> は symbolic link をたどるが、<code>O_CREAT</code> と <code>O_EXCL</code> の両方が付いている場合は例外で、
その時に symbolic link を開こうとすると、エラーとなり、 <code>errno</code> に <code>EEXIST</code> がセットされる。
これは権限のあるプロセスが誤ってファイルに書き込みをしないようにするためである。</li>
</ul>
</li>
</ul>


<h2>symlink and readlink Functions</h2>

<ul>
<li>symbolic link を作成するには <code>symlink()</code> を使う</li>
</ul>


<pre><code class="c">#include &lt;unistd.h&gt;
int symlink(const char *actualpath, const char *sympath);

return 0 if OK, -1 on error
</code></pre>

<ul>
<li><code>open()</code> は symbolic link をたどってしまうため、symbolic link 自身を open したい場合は <code>readlink()</code> を使う</li>
</ul>


<pre><code class="c">#include &lt;unistd.h&gt;
ssize_t readlink(const char *restrict pathname, char *restrict buf, size_t bufsize);

return number of bytes read if OK, -1 on error
</code></pre>

<ul>
<li>この関数1つで open, read, close を行なっている。</li>
</ul>


<h2>File Times</h2>

<p>各ファイルでは3種類の時刻が管理されている
- <code>st_atime</code>: 最後にファイルにアクセスされた時刻。<code>read()</code> など。<code>ls -u</code> でソート
- <code>st_mtime</code>: 最後にファイルの中身が変更された時刻。<code>write()</code> など。<code>ls -t</code> でソート
- <code>st_ctime</code>: 最後に i-node のステータスが変更された時刻。<code>chmod(), chown()</code> など。<code>ls -c</code> でソート</p>

<h2>utime Function</h2>

<p>ファイルの access time や modification time を変更するには <code>utime()</code> を使う</p>

<pre><code class="c">#include &lt;utime.h&gt;
int utime(const char *pathname, const struct utimbuf *times);

return 0 if OK, -1 on error
</code></pre>

<p><code>utimbuf</code> 構造体は以下のようになっている</p>

<pre><code class="c">struct utimbuf {
    time_t actime;  /* access time */
    time_t modtime; /* modification time*/
}
</code></pre>

<ul>
<li><em>times</em> が null の場合、access time と modification time は現在の時刻に更新される。</li>
<li>chenged-status time を変更する関数は無い。<code>utime()</code> が実行されると自動的に更新される。</li>
</ul>


<h2>mkdir and rmdir Functions</h2>

<ul>
<li><code>mkdir()</code> で空の directory を作成できる。</li>
</ul>


<pre><code class="c">#include &lt;sys/stat.h&gt;
int mkdir(const char *pathname, mode_t mode);
return 0 if OK, -1 on error
</code></pre>

<ul>
<li><code>.</code> と <code>..</code> は自動的に作られる。</li>
<li><em>mode</em> にはプロセスの mask による変更が加えられる。</li>
<li><p>directory の場合、execute bit を付けないと directory 内のファイルにアクセスできなくなるので注意</p></li>
<li><p>空の directory を削除するには <code>rmdir()</code> を使う</p></li>
</ul>


<pre><code class="c">#include &lt;unistd.h&gt;
int rmdir(const char *pathname);

return 0 if OK, -1 on error
</code></pre>

<ul>
<li>link count が 0 でも、その directory を open しているプロセスがあれば、close されるまで領域は解放されない。
解放はされないが、その directory 内に新しくファイルを置くことはできなくなる。</li>
</ul>


<h2>Reading Directories</h2>

<p>directory を読むには、以下のような関数を使う</p>

<pre><code class="c">#include &lt;dirent.h&gt;
DIR *opendir(const char *pathname);    return pointer if OK, NULL on error
struct dirent *readdir(DIR *dp);       return pointer if OK, NULL at end of directory or error
void rewinddir(DIR *dp);
int closedir(DIR *dp);                 return 0 if OK, -1 on error
long telldir(DIR *dp);                 return current location in directory associated with dp
void seekdir(DIR *dp, long loc);
</code></pre>

<p><code>dirent</code> 構造体 の定義は実装依存だが、少なくとも以下の2つは含まれている</p>

<pre><code class="c">struct dirent {
    ino_t d_ino;                    /* i-node number */ 
    char  d_name[NAME_MAX + 1];     /* null-terminated filename */
}
</code></pre>

<ul>
<li><code>DIR</code> は <code>FILE</code> 構造体のようなもので、directory が read されるのを管理するための構造体</li>
<li>directory entries の順番は実装依存だが、たいていアルファベット順にはなっていない</li>
<li><code>rewinddir()</code> は DIR のポインタを先頭に戻す</li>
</ul>


<h2>chdir, fchdir, and getcwd Functions</h2>

<ul>
<li>すべてのプロセスは current working directory を持っている。

<ul>
<li>user がログインすると、current working directory が <code>/etc/passwd</code> の第6フィールドにセットされた home directory に設定される。</li>
</ul>
</li>
<li><p>current working directory はプロセスの attribute である。</p></li>
<li><p><code>chdir()</code> や <code>fchdir()</code> を使うと、それを呼んだプロセスの current working directory が変更できる</p></li>
</ul>


<pre><code class="c">#include &lt;unistd.h&gt;
int chdir(const char *pathname);
int fchdir(int filedes);

return 0 if OK, -1 on error
</code></pre>

<ul>
<li>kernel は current working directory の full path を管理しているわけではない</li>
<li>full path を取得するのは、v-node を辿っていけばいいが、そのような関数は既にあり、<code>getcwd()</code> で full path が取得できる</li>
</ul>


<pre><code class="c">#include &lt;unistd.h&gt;
char *getcwd(char *buf, size_t size);

return buf if OK, NULL on error
</code></pre>

<h2>Device Special Files</h2>

<p><code>stat</code> 構造体には <code>st_dev</code> と <code>st_rdev</code> の2つのフィールドがある。</p>

<ul>
<li>すべてのファイルシステムには major と minor 2種類のデバイス番号が付けられている。

<ul>
<li>型は <code>dev_t</code> 型</li>
<li>major number はデバイスドライバを識別する番号</li>
<li>minor number はサブデバイスを識別する番号</li>
<li>同じディスクドライブにあるファイルシステムはたいてい同じ major number を持つが、異なる minor number を持つ</li>
</ul>
</li>
<li>major, minor number はそれぞれ <code>major()</code>, <code>minor()</code> マクロで取得できる</li>
<li><code>st_dev</code> はそのファイル名や i-node が格納されているデバイス番号</li>
<li>character special files と block special files の場合のみ <code>st_rdev</code> に値が入っている。
これは実際のデバイスのデバイス番号である。

<ul>
<li><code>/dev/tty0</code> や <code>/dev/hda3</code> などの <code>st_dev</code> のデバイス番号は 0/7 などの <code>devfs</code> 仮想ファイルシステムになっている。
実際のデバイス番号は <code>st_rdev</code> に書かれた 4/0 などである。</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Advanced Programming in the UNIX Environment Chapter 3]]></title>
    <link href="http://kentaktwo.github.com/blog/2012/06/30/apue-chapter-3/"/>
    <updated>2012-06-30T13:49:00+09:00</updated>
    <id>http://kentaktwo.github.com/blog/2012/06/30/apue-chapter-3</id>
    <content type="html"><![CDATA[<h1>File I/O</h1>

<!--more-->


<h2>File Descriptors</h2>

<ul>
<li>標準入出力は <code>&lt;unistd.h&gt;</code> に定義されている

<ul>
<li><code>STDIN_FILENO</code>: 0</li>
<li><code>STDOUT_FILENO</code>: 1</li>
<li><code>STDERR_FILENO</code>: 2</li>
<li>0, 1, 2 に割り当てられているのは慣習であり、UNIX の取り決めではない</li>
</ul>
</li>
<li>File descriptor の範囲は 0 から <code>OPEN_MAX</code> まで

<ul>
<li>昔は 19 までだったが最近は 63 まであるシステムが多い</li>
</ul>
</li>
</ul>


<h2>open Function</h2>

<pre><code class="c">#include &lt;fcntl.h&gt;
int open(const char *pathname, int oflag, ... /* mode_t mode */ );
</code></pre>

<ul>
<li>ファイルを開いたり作成したりする</li>
<li>第二引数 (<em>oflag</em>) に入れるオプションは <code>&lt;fcntl.h&gt;</code> に定義されている

<ul>
<li><code>O_RDONLY</code>, <code>O_WRONLY</code>, <code>O_RDWR</code> のいずれかは必須</li>
</ul>
</li>
<li>open される file descriptor は使われていないもののうち最小のものになる

<ul>
<li>なので、標準出力(1) を close して open すると 1番に割り当てられたりする</li>
</ul>
</li>
<li>ファイル名が長すぎた (<code>NAME_MAX</code>以上) ときどうするかは OS 依存

<ul>
<li>System V 系だと勝手にはみ出た分を切り捨てる</li>
<li>BSD 系だとエラー (<code>ENAMETOOLONG</code>) を出す</li>
<li>POSIX.1 なら <code>_POSIX_NO_TRUNC</code> を定義すればエラーを出すようにできる</li>
</ul>
</li>
</ul>


<h2>creat Function</h2>

<pre><code class="c">#include &lt;fcntl.h&gt;
int creat(const char *pathname, mode_t mode);
</code></pre>

<ul>
<li><code>open(pathname, O_WRONLY | O_CREAT | O_TRUNC, mode);</code> と同じ</li>
</ul>


<h2>close Function</h2>

<pre><code class="c">#include &lt;unistd.h&gt;
int close(int filedes);
</code></pre>

<ul>
<li>プロセスが終了するときにはカーネルによって自動的に close される</li>
</ul>


<h2>lseek Function</h2>

<pre><code class="c">#include &lt;unistd.h&gt;
off_t lseek(int filedes, off_t offset, int whence);
</code></pre>

<ul>
<li>オフセットの位置を指定する</li>
<li>open されたファイルは現在のファイルの始めからのオフセットを非負整数で持っている</li>
<li>デフォルトでは open されたときオフセットは 0 に設定される (<code>O_APPEND</code> を設定している場合を除く)</li>
<li><em>offset</em> の値の適用の仕方は <em>whence</em> の値による

<ul>
<li><code>SEEK_SET</code>: ファイルの始めから <em>offset</em> 進めたところ</li>
<li><code>SEEK_CUR</code>: 現在のオフセットから <em>offset</em> 進めたところ</li>
<li><code>SEEK_END</code>: ファイルの終わり（正確には現在のファイルサイズ）から <em>offset</em> 進めたところ</li>
</ul>
</li>
<li><code>lseek</code> は新しいファイルオフセットを返すので、これを利用して現在のオフセットを取得することができる
<code>c
off_t currpos = lseek(fd, 0, SEEK_CUR);
</code></li>
<li>ファイルオフセットをファイルサイズより大きくして write すると、その間は 0 で埋められるが、ディスクブロックは割り当てられない</li>
</ul>


<h2>od command</h2>

<ul>
<li>ファイルコンテンツを見る</li>
<li><code>-c</code> オプションをつけるとコンテンツを文字として表示する</li>
</ul>


<h2>read Function</h2>

<pre><code class="c">#include &lt;unistd.h&gt;
ssize_t read(int filedes, void *buf, size_t nbytes);
</code></pre>

<ul>
<li>戻り値は実際に読み込んだバイト数

<ul>
<li>EOF のときは 0</li>
</ul>
</li>
</ul>


<h2>write Function</h2>

<pre><code class="c">#include &lt;unistd.h&gt;
ssize_t write(int filedes, const void *buf, size_t nbytes);
</code></pre>

<ul>
<li>ディスクがいっぱいで書き込めなくなったときはエラー (-1) を返す</li>
</ul>


<h2>File Sharing</h2>

<ul>
<li>カーネルは open されたファイルを3種類のデータ構造で管理している

<ul>
<li>process table

<ul>
<li>各プロセスが持つ</li>
<li>open された file descriptor のテーブル</li>
<li>各 descriptor は file table へのポインタを持つ</li>
</ul>
</li>
<li>file table

<ul>
<li>ファイルステータス (read, write, append, sync など)、現在のファイルオフセットを持つ</li>
<li>v-node table へのポインタを持つ</li>
</ul>
</li>
<li>v-node table

<ul>
<li>ファイルタイプ、i-node 情報を持つ</li>
<li>i-node はファイルのオーナー、サイズ、実データの格納場所へのポインタなどを持っている</li>
</ul>
</li>
</ul>
</li>
<li>Linux には v-node は無いが、その代わりに generic i-node が使われる</li>
<li>2つのプロセスが同じファイルを open すると、file table は2つできるが、それらが同じ v-node table を指す</li>
</ul>


<h2>Atomic Operations</h2>

<pre><code class="c">#include &lt;unistd.h&gt;
ssize_t pread(int filedes, void *buf, size_t nbytes, off_t offset);
ssize_t pwrite(int filedes, const void *buf, size_t nbytes, off_t offset);
</code></pre>

<p><code>lseek</code> と <code>read</code> または <code>write</code> を atomic に行なってくれる</p>

<h2>dup and dup2 Functions</h2>

<pre><code class="c">#include &lt;unistd.h&gt;
int dup(int filedes);
int dup2(int filedes, int filedes2);
</code></pre>

<ul>
<li>file descriptor を複製する

<ul>
<li>dup では複製されたディスクリプタは使用可能なディスクリプタのうち最小のものとなる</li>
<li>dup2 では複製されたディスクリプタの番号を <em>filedes2</em> で指定する</li>
</ul>
</li>
<li>元のディスクリプタと複製されたディスクリプタは同じ file table を指す

<ul>
<li>なので、ファイルステータスやファイルオフセットなどが共有される</li>
</ul>
</li>
</ul>


<h2>sync, fsync, and fdatasync Functions</h2>

<pre><code class="c">#include &lt;unistd.h&gt;
int fsync(int filedes);
int fdatasync(int filedes);
int sync(void);
</code></pre>

<ul>
<li>UNIX の実装では、write されたデータはカーネルによって一旦バッファにコピーされ、少し後にディスクに書き込まれる</li>
<li><code>sync</code> を呼ぶと、すべての変更されたブロックを書き込む

<ul>
<li>通常デーモンによって30秒に1回 <code>sync</code> が呼ばれている</li>
<li>ディスクの書き込みが終わるのを待たずに return する</li>
</ul>
</li>
<li><code>fsync</code> は特定のファイルディスクリプタに対して行う

<ul>
<li>ディスクへの書き込みが終わるのを待つ</li>
</ul>
</li>
<li><code>fdatasync</code> はデータの更新のみを行う

<ul>
<li><code>fsync</code> はファイル属性の更新も行う</li>
</ul>
</li>
</ul>


<h2>fcntl Function</h2>

<pre><code class="c">#include &lt;fcntl.h&gt;
int fcntl(int filedes, int cmd, ... /* int arg */ );
</code></pre>

<ul>
<li>open されたファイルのプロパティを変更する</li>
<li>以下のようなことができる (<em>cmd</em> で指定)

<ul>
<li>descriptor の複製</li>
<li>descriptor flag の取得・設定</li>
<li>file status flag の取得・設定</li>
<li>オーナーシップ (process ID, group ID) の取得・設定</li>
<li>record lock の取得・設定（詳しくは14章）</li>
</ul>
</li>
</ul>


<h2>/dev/fd</h2>

<ul>
<li><code>/dev/fd</code> に 0, 1, 2 と呼ばれるファイルがあり、それぞれ file descriptor 0, 1, 2 に対応している</li>
<li><code>/dev/fd/n</code> を open する際、<em>mode</em> の値は無視される。 <code>/dev/fd/0</code> は read only であり、
<code>c
  fd = open("/dev/fd/0", O_RDWR);
</code>
としても fd に書き込むことはできない</li>
<li>shell で使われることが多い
<code>sh
filter file2 | cat file1 - file3 | lpr
</code>
は file1, filter file2, file3 を cat しているが (<code>-</code> は標準入力)、
<code>-</code> は場合によって標準入力だったり出力だったりわかりにくいので、
<code>sh
filter file2 | cat file1 /dev/fd/0 file3 | lpr
</code>
として明確に書くことができる。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Advanced Programming in the UNIX Environment Chapter 2]]></title>
    <link href="http://kentaktwo.github.com/blog/2012/05/02/apue-chapter-2/"/>
    <updated>2012-05-02T14:31:00+09:00</updated>
    <id>http://kentaktwo.github.com/blog/2012/05/02/apue-chapter-2</id>
    <content type="html"><![CDATA[<h1>UNIX Standardization and Implementations</h1>

<!--more-->


<h2>Limits</h2>

<ul>
<li>Compile-time limits

<ul>
<li>short integer の最大値など</li>
<li>ヘッダに定義</li>
<li>コンパイル時にインクルードされる</li>
</ul>
</li>
<li>Runtime limits

<ul>
<li>filename の最大文字数など</li>
<li>プロセスが関数を呼んで値を取得する必要がある</li>
</ul>
</li>
<li>Runtime limits は以下の関数を呼ぶことで取得できる

<ul>
<li><code>sysconf()</code>

<ul>
<li>file や directory に関係しない limit</li>
<li><code>_SC_</code> で始まる値を取得できる</li>
</ul>
</li>
<li><code>pathconf()</code>

<ul>
<li>file や directory に関係する limit</li>
<li><code>_PC_</code> で始まる値を取得できる</li>
</ul>
</li>
<li><code>fpathconf()</code>: <code>pathconf</code> の引数がファイルディスクリプタになった版</li>
</ul>
</li>
<li>limits は未定義なこともある

<ul>
<li>e.g. pathname の最大値

<ol>
<li> <code>&lt;limits.h&gt;</code> に定義されていればその値を使う</li>
<li> 定義されていなければ、<code>pathconf("/", _PC_PATH_MAX)</code> して取得する</li>
<li> 取得できなければ、適当な値を推測して使う</li>
</ol>
</li>
</ul>
</li>
</ul>


<h2>Primitive System Data Types</h2>

<ul>
<li>C のデータ型は UNIX システムに依存することがある</li>
<li><code>&lt;sys/types.h&gt;</code> に実装依存のデータ型 (<em>primitive system data types</em>) が定義されている

<ul>
<li><code>clock_t</code>, <code>size_t</code>, <code>time_t</code> など</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Advanced Programming in the UNIX Environment Chapter 1]]></title>
    <link href="http://kentaktwo.github.com/blog/2012/04/28/apue-chapter-1/"/>
    <updated>2012-04-28T22:45:00+09:00</updated>
    <id>http://kentaktwo.github.com/blog/2012/04/28/apue-chapter-1</id>
    <content type="html"><![CDATA[<h1>UNIX System Overview</h1>

<!--more-->


<h2>UNIX Architecture</h2>

<ul>
<li>OS (Operating System) とは、コンピュータのハードウェアを制御し、プログラムが動作する環境を提供するソフトウェアのこと</li>
<li>このソフトウェアのことを <em>kernel</em> と呼ぶ</li>
<li>kernel とのインターフェースとなるソフトウェア群を <em>system calls</em> と呼ぶ</li>
<li>shell は他のアプリケーションを動かすためのインターフェースとなるアプリケーション</li>
</ul>


<h2>Logging In</h2>

<ul>
<li>ログイン名は たいてい <code>/etc/passwd</code> に書かれている
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'>&lt;h1&gt;最近はパスワードは別ファイルになっていることが多い&lt;/h1&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;&lt;loginName&gt;:&lt;encryptedPassword&gt;:&lt;userID&gt;:&lt;groupID&gt;:&lt;comment&gt;:&lt;homeDirectory&gt;:&lt;shellProgram&gt;
</span></code></pre></td></tr></table></div></figure></p></li>
</ul>


<h2>Files and Directories</h2>

<ul>
<li><em>directory</em> とは directory entries を含んだファイルのこと</li>
<li>directory の中にある名前を <em>filename</em> という

<ul>
<li>filename には <code>/</code> と null 文字以外の全ての文字が使える</li>
</ul>
</li>
<li>UNIX のマニュアルは section 1 から 8 まである

<ul>
<li>ls は Section 1 にある</li>
</ul>
</li>
</ul>


<h2>Input and Output</h2>

<ul>
<li>File descriptors とは、カーネルがプロセスからアクセスされるファイルを識別するための non-negative な整数のこと</li>
<li>Unbuffered I/O は <code>open</code>, <code>read</code>, <code>write</code>, <code>lseek</code>, <code>close</code> によって提供される</li>
<li>Standard I/O は unbuffered I/O にバッファインターフェースを提供する

<ul>
<li>バッファサイズを気にする必要がない</li>
<li>行ごとの処理が楽 (<code>fgets</code> etc.)</li>
</ul>
</li>
</ul>


<h2>Programs and Processes</h2>

<ul>
<li><em>program</em> とは、ディレクトリにある実行可能なファイルのこと</li>
<li>program はメモリに読み込まれ、カーネルによって実行される</li>
<li>実行中のプログラムのことを <em>process</em> と呼ぶ

<ul>
<li><em>task</em> と呼んだりする OS もある</li>
</ul>
</li>
<li>UNIX は全てのプロセスにユニークな <em>process ID</em> を割り振る

<ul>
<li>process ID は non-negative な整数</li>
</ul>
</li>
<li>プロセス内で動いているスレッドは同じアドレス空間、ファイルディスクリプタ、スタック等のプロセスに関する属性を共有する

<ul>
<li>そのため、矛盾を起こさないように同期をとる必要がある</li>
</ul>
</li>
<li>スレッドは thread ID で管理される

<ul>
<li>thread ID はプロセスごとに閉じている</li>
</ul>
</li>
</ul>


<h2>Error Handling</h2>

<ul>
<li>UNIX システム関数でエラーが起こると、たいてい負の値が返り、<code>errno</code> と呼ばれる整数がセットされる

<ul>
<li><code>errno</code> が取りうる値は <code>&lt;errno.h&gt;</code> に定義されている</li>
<li>UNIX マニュアルの Section 2 の始め (<code>intro(2)</code>) で <code>errno</code> の説明が見れる

<ul>
<li>Linux では <code>errno(3)</code></li>
</ul>
</li>
</ul>
</li>
<li><code>errno</code> はエラーが起こらない限りクリアされないので、関数の戻り値を見てから <code>errno</code> を調べる必要がある</li>
<li><code>errno</code> に 0 がセットされることはない</li>
<li><code>strerror()</code> で <code>errno</code> に対応するエラーメッセージが取得できる</li>
<li><code>perror()</code> で引数に渡したメッセージと現在の <code>errno</code> に対応するエラーメッセージを standard error に出力できる</li>
<li><code>&lt;errno.h&gt;</code> に定義されたエラーは fatal なものと nonfatal なものに分かれる

<ul>
<li>fatal なエラーが起きた場合はエラーメッセージを出してプログラムを終了すべきである</li>
<li>リソース不足で起きるエラーなどが nonfatal なエラーに分類される</li>
<li>リソース関連の nonfatal エラーは <code>EAGAIN</code>, <code>ENFILE</code>, <code>ENOBUFS</code>, <code>ENOLCK</code>, <code>ENOSPC</code>, <code>ENOSR</code>, <code>EWOULDBLOCK</code>, <code>ENOMEM</code> など</li>
<li>リソース関連のエラーが起きた場合は少し待ってやり直すことで対応できることがある</li>
</ul>
</li>
</ul>


<h2>User Identification</h2>

<ul>
<li><em>user ID</em> はログイン名が作られたときに割り振られ、変更することはできない</li>
<li>user ID が 0 のユーザは <em>root</em> または <em>superuser</em> と呼ばれる</li>
<li><em>group ID</em> もログイン名が作られた時に割り振られる。</li>
<li>group name を group ID にマップするファイルが <code>/etc/group</code> にあり、group file と呼ばれる</li>
<li><code>getuid()</code> や <code>getgid()</code> で user ID や group ID が取れる</li>
<li>group ID の他に追加でグループに所属させることもできる (<em>supplementary group ID</em>)

<ul>
<li>16 個まで</li>
</ul>
</li>
</ul>


<h2>Signals</h2>

<ul>
<li>signal は何かが起きたことをプロセスに伝える手段

<ul>
<li>例えばゼロ除算が発生すると、<code>SIGFPE</code> がプロセスに送られる</li>
</ul>
</li>
<li>プロセスのシグナルの処理の仕方は 3 通りある

<ol>
<li> シグナルを無視する</li>
<li> デフォルトの動作を実行させる</li>
<li> シグナルが起きた時に呼ぶ関数を与える</li>
</ol>
</li>
<li>DELETE または Ctrl-C は <em>interrupt key</em>, Ctrl-backslash は <em>quit key</em> と呼ばれ、実行中のプロセスを終了させるのに使う</li>
<li><code>kill()</code> を呼ぶとシグナルを送ることができる</li>
<li>シグナルを送るためには、そのプロセスのオーナーでなければならない</li>
</ul>


<h2>Time Values</h2>

<ul>
<li>UNIX は2種類の時間を管理している

<ol>
<li> Calendar time: Epoch (UTC 1970 1/1 00:00:00) からの秒数

<ul>
<li><code>time_t</code> 型はこの値を持っている</li>
</ul>
</li>
<li> Process time: clock によって計測される

<ul>
<li>プロセスによって使われたリソースを計測するのに使う</li>
<li>CPU time ともいう</li>
<li><code>clock_t</code> 型がこの値を持っている</li>
</ul>
</li>
</ol>
</li>
<li>プロセスの実行時間を計測すると、3種類の値が得られる

<ul>
<li>Clock time: プロセスを実行するのにかかった時間

<ul>
<li>システム上で動いている他のプロセスの影響を受ける</li>
</ul>
</li>
<li>User CPU time: ユーザの命令が実行された時間（ループ処理など）</li>
<li>System CPU time: システムコールを行うのにかかった時間</li>
</ul>
</li>
<li>user CPU time と system CPU time を合わせて <em>CPU time</em> と呼ぶ</li>
</ul>


<h2>System Calls and Library Functions</h2>

<ul>
<li>system call のドキュメントは <em>UNIX Programmer&rsquo;s Manual</em> の Section 2 にある</li>
<li>Section 3 にはプログラマが普段使うであろう関数 (Library functions) の説明が書かれている (<code>printf()</code> etc.)

<ul>
<li>ライブラリ関数は複数のシステムコールの組み合わせでできている</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
</feed>
