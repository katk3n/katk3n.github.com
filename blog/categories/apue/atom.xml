<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: apue | ApprEngineer.log]]></title>
  <link href="http://kentaktwo.github.com/blog/categories/apue/atom.xml" rel="self"/>
  <link href="http://kentaktwo.github.com/"/>
  <updated>2012-08-11T20:30:29+09:00</updated>
  <id>http://kentaktwo.github.com/</id>
  <author>
    <name><![CDATA[kentaktwo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Advanced Programming in the UNIX enviroment Chapter 3]]></title>
    <link href="http://kentaktwo.github.com/blog/2012/06/30/apue-chapter-3/"/>
    <updated>2012-06-30T13:49:00+09:00</updated>
    <id>http://kentaktwo.github.com/blog/2012/06/30/apue-chapter-3</id>
    <content type="html"><![CDATA[<h1>File I/O</h1>

<!--more-->


<h2>File Descriptors</h2>

<ul>
<li>標準入出力は <code>&lt;unistd.h&gt;</code> に定義されている

<ul>
<li><code>STDIN_FILENO</code>: 0</li>
<li><code>STDOUT_FILENO</code>: 1</li>
<li><code>STDERR_FILENO</code>: 2</li>
<li>0, 1, 2 に割り当てられているのは慣習であり、UNIX の取り決めではない</li>
</ul>
</li>
<li>File descriptor の範囲は 0 から <code>OPEN_MAX</code> まで

<ul>
<li>昔は 19 までだったが最近は 63 まであるシステムが多い</li>
</ul>
</li>
</ul>


<h2>open Function</h2>

<p>``` c</p>

<h1>include &lt;fcntl.h></h1>

<p>int open(const char <em>pathname, int oflag, ... /</em> mode_t mode */ );
<code>``
- ファイルを開いたり作成したりする
- 第二引数 (_oflag_) に入れるオプションは</code>&lt;fcntl.h>` に定義されている</p>

<pre><code>- `O_RDONLY`, `O_WRONLY`, `O_RDWR` のいずれかは必須
</code></pre>

<ul>
<li>open される file descriptor は使われていないもののうち最小のものになる

<ul>
<li>なので、標準出力(1) を close して open すると 1番に割り当てられたりする</li>
</ul>
</li>
<li>ファイル名が長すぎた (<code>NAME_MAX</code>以上) ときどうするかは OS 依存

<ul>
<li>System V 系だと勝手にはみ出た分を切り捨てる</li>
<li>BSD 系だとエラー (<code>ENAMETOOLONG</code>) を出す</li>
<li>POSIX.1 なら <code>_POSIX_NO_TRUNC</code> を定義すればエラーを出すようにできる</li>
</ul>
</li>
</ul>


<h2>creat Function</h2>

<p>``` c</p>

<h1>include &lt;fcntl.h></h1>

<p>int creat(const char *pathname, mode_t mode);
<code>``
-</code>open(pathname, O_WRONLY | O_CREAT | O_TRUNC, mode);` と同じ</p>

<h2>close Function</h2>

<p>``` c</p>

<h1>include &lt;unistd.h></h1>

<p>int close(int filedes);
```
- プロセスが終了するときにはカーネルによって自動的に close される</p>

<h2>lseek Function</h2>

<p>``` c</p>

<h1>include &lt;unistd.h></h1>

<p>off_t lseek(int filedes, off_t offset, int whence);
<code>``
- オフセットの位置を指定する
- open されたファイルは現在のファイルの始めからのオフセットを非負整数で持っている
- デフォルトでは open されたときオフセットは 0 に設定される (</code>O_APPEND` を設定している場合を除く)
- <em>offset</em> の値の適用の仕方は <em>whence</em> の値による</p>

<pre><code>- `SEEK_SET`: ファイルの始めから _offset_ 進めたところ
- `SEEK_CUR`: 現在のオフセットから _offset_ 進めたところ
- `SEEK_END`: ファイルの終わり（正確には現在のファイルサイズ）から _offset_ 進めたところ
</code></pre>

<ul>
<li><code>lseek</code> は新しいファイルオフセットを返すので、これを利用して現在のオフセットを取得することができる
<code>c
off_t currpos = lseek(fd, 0, SEEK_CUR);
</code></li>
<li>ファイルオフセットをファイルサイズより大きくして write すると、その間は 0 で埋められるが、ディスクブロックは割り当てられない</li>
</ul>


<h2>od command</h2>

<ul>
<li>ファイルコンテンツを見る</li>
<li><code>-c</code> オプションをつけるとコンテンツを文字として表示する</li>
</ul>


<h2>read Function</h2>

<p>``` c</p>

<h1>include &lt;unistd.h></h1>

<p>ssize_t read(int filedes, void *buf, size_t nbytes);
```
- 戻り値は実際に読み込んだバイト数</p>

<pre><code>- EOF のときは 0
</code></pre>

<h2>write Function</h2>

<p>``` c</p>

<h1>include &lt;unistd.h></h1>

<p>ssize_t write(int filedes, const void *buf, size_t nbytes);
```
- ディスクがいっぱいで書き込めなくなったときはエラー (-1) を返す</p>

<h2>File Sharing</h2>

<ul>
<li>カーネルは open されたファイルを3種類のデータ構造で管理している

<ul>
<li>process table

<ul>
<li>各プロセスが持つ</li>
<li>open された file descriptor のテーブル</li>
<li>各 descriptor は file table へのポインタを持つ</li>
</ul>
</li>
<li>file table

<ul>
<li>ファイルステータス (read, write, append, sync など)、現在のファイルオフセットを持つ</li>
<li>v-node table へのポインタを持つ</li>
</ul>
</li>
<li>v-node table

<ul>
<li>ファイルタイプ、i-node 情報を持つ</li>
<li>i-node はファイルのオーナー、サイズ、実データの格納場所へのポインタなどを持っている</li>
</ul>
</li>
</ul>
</li>
<li>Linux には v-node は無いが、その代わりに generic i-node が使われる</li>
<li>2つのプロセスが同じファイルを open すると、file table は2つできるが、それらが同じ v-node table を指す</li>
</ul>


<h2>Atomic Operations</h2>

<p>``` c</p>

<h1>include &lt;unistd.h></h1>

<p>ssize_t pread(int filedes, void <em>buf, size_t nbytes, off_t offset);
ssize_t pwrite(int filedes, const void </em>buf, size_t nbytes, off_t offset);
<code>``
</code>lseek<code>と</code>read<code>または</code>write` を atomic に行なってくれる</p>

<h2>dup and dup2 Functions</h2>

<p>``` c</p>

<h1>include &lt;unistd.h></h1>

<p>int dup(int filedes);
int dup2(int filedes, int filedes2);
```
- file descriptor を複製する</p>

<pre><code>- dup では複製されたディスクリプタは使用可能なディスクリプタのうち最小のものとなる
- dup2 では複製されたディスクリプタの番号を _filedes2_ で指定する
</code></pre>

<ul>
<li>元のディスクリプタと複製されたディスクリプタは同じ file table を指す

<ul>
<li>なので、ファイルステータスやファイルオフセットなどが共有される</li>
</ul>
</li>
</ul>


<h2>sync, fsync, and fdatasync Functions</h2>

<p>``` c</p>

<h1>include &lt;unistd.h></h1>

<p>int fsync(int filedes);
int fdatasync(int filedes);
int sync(void);
<code>``
- UNIX の実装では、write されたデータはカーネルによって一旦バッファにコピーされ、少し後にディスクに書き込まれる
-</code>sync` を呼ぶと、すべての変更されたブロックを書き込む</p>

<pre><code>- 通常デーモンによって30秒に1回 `sync` が呼ばれている
- ディスクの書き込みが終わるのを待たずに return する
</code></pre>

<ul>
<li><code>fsync</code> は特定のファイルディスクリプタに対して行う

<ul>
<li>ディスクへの書き込みが終わるのを待つ</li>
</ul>
</li>
<li><code>fdatasync</code> はデータの更新のみを行う

<ul>
<li><code>fsync</code> はファイル属性の更新も行う</li>
</ul>
</li>
</ul>


<h2>fcntl Function</h2>

<p>``` c</p>

<h1>include &lt;fcntl.h></h1>

<p>int fcntl(int filedes, int cmd, ... /<em> int arg </em>/ );
```
- open されたファイルのプロパティを変更する
- 以下のようなことができる (<em>cmd</em> で指定)</p>

<pre><code>- descriptor の複製
- descriptor flag の取得・設定
- file status flag の取得・設定
- オーナーシップ (process ID, group ID) の取得・設定
- record lock の取得・設定（詳しくは14章）
</code></pre>

<h2>/dev/fd</h2>

<ul>
<li><code>/dev/fd</code> に 0, 1, 2 と呼ばれるファイルがあり、それぞれ file descriptor 0, 1, 2 に対応している</li>
<li><code>/dev/fd/n</code> を open する際、<em>mode</em> の値は無視される。 <code>/dev/fd/0</code> は read only であり、
<code>c
  fd = open("/dev/fd/0", O_RDWR);
</code>
としても fd に書き込むことはできない</li>
<li>shell で使われることが多い
<code>sh
filter file2 | cat file1 - file3 | lpr
</code>
は file1, filter file2, file3 を cat しているが (<code>-</code> は標準入力)、
<code>-</code> は場合によって標準入力だったり出力だったりわかりにくいので、
<code>sh
filter file2 | cat file1 /dev/fd/0 file3 | lpr
</code>
として明確に書くことができる。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Advanced Programming in the UNIX environment Chapter 2]]></title>
    <link href="http://kentaktwo.github.com/blog/2012/05/02/apue-chapter-2/"/>
    <updated>2012-05-02T14:31:00+09:00</updated>
    <id>http://kentaktwo.github.com/blog/2012/05/02/apue-chapter-2</id>
    <content type="html"><![CDATA[<h1>UNIX Standardization and Implementations</h1>

<!--more-->


<h2>Limits</h2>

<ul>
<li>Compile-time limits

<ul>
<li>short integer の最大値など</li>
<li>ヘッダに定義</li>
<li>コンパイル時にインクルードされる</li>
</ul>
</li>
<li>Runtime limits

<ul>
<li>filename の最大文字数など</li>
<li>プロセスが関数を呼んで値を取得する必要がある</li>
</ul>
</li>
<li>Runtime limits は以下の関数を呼ぶことで取得できる

<ul>
<li><code>sysconf()</code>

<ul>
<li>file や directory に関係しない limit</li>
<li><code>_SC_</code> で始まる値を取得できる</li>
</ul>
</li>
<li><code>pathconf()</code>

<ul>
<li>file や directory に関係する limit</li>
<li><code>_PC_</code> で始まる値を取得できる</li>
</ul>
</li>
<li><code>fpathconf()</code>: <code>pathconf</code> の引数がファイルディスクリプタになった版</li>
</ul>
</li>
<li>limits は未定義なこともある

<ul>
<li>e.g. pathname の最大値

<ol>
<li><code>&lt;limits.h&gt;</code> に定義されていればその値を使う</li>
<li>定義されていなければ、<code>pathconf("/", _PC_PATH_MAX)</code> して取得する</li>
<li>取得できなければ、適当な値を推測して使う</li>
</ol>
</li>
</ul>
</li>
</ul>


<h2>Primitive System Data Types</h2>

<ul>
<li>C のデータ型は UNIX システムに依存することがある</li>
<li><code>&lt;sys/types.h&gt;</code> に実装依存のデータ型 (<em>primitive system data types</em>) が定義されている

<ul>
<li><code>clock_t</code>, <code>size_t</code>, <code>time_t</code> など</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Advanced Programming in the UNIX environment Chapter 1]]></title>
    <link href="http://kentaktwo.github.com/blog/2012/04/28/apue-chapter-1/"/>
    <updated>2012-04-28T22:45:00+09:00</updated>
    <id>http://kentaktwo.github.com/blog/2012/04/28/apue-chapter-1</id>
    <content type="html"><![CDATA[<h1>UNIX System Overview</h1>

<!--more-->


<h2>UNIX Architecture</h2>

<ul>
<li>OS (Operating System) とは、コンピュータのハードウェアを制御し、プログラムが動作する環境を提供するソフトウェアのこと</li>
<li>このソフトウェアのことを <em>kernel</em> と呼ぶ</li>
<li>kernel とのインターフェースとなるソフトウェア群を <em>system calls</em> と呼ぶ</li>
<li>shell は他のアプリケーションを動かすためのインターフェースとなるアプリケーション</li>
</ul>


<h2>Logging In</h2>

<ul>
<li>ログイン名は たいてい <code>/etc/passwd</code> に書かれている
``` sh

<h1>最近はパスワードは別ファイルになっていることが多い</h1>

<p><loginName>:<encryptedPassword>:<userID>:<groupID>:<comment>:<homeDirectory>:<shellProgram>
```</p></li>
</ul>


<h2>Files and Directories</h2>

<ul>
<li><em>directory</em> とは directory entries を含んだファイルのこと</li>
<li>directory の中にある名前を <em>filename</em> という

<ul>
<li>filename には <code>/</code> と null 文字以外の全ての文字が使える</li>
</ul>
</li>
<li>UNIX のマニュアルは section 1 から 8 まである

<ul>
<li>ls は Section 1 にある</li>
</ul>
</li>
</ul>


<h2>Input and Output</h2>

<ul>
<li>File descriptors とは、カーネルがプロセスからアクセスされるファイルを識別するための non-negative な整数のこと</li>
<li>Unbuffered I/O は <code>open</code>, <code>read</code>, <code>write</code>, <code>lseek</code>, <code>close</code> によって提供される</li>
<li>Standard I/O は unbuffered I/O にバッファインターフェースを提供する

<ul>
<li>バッファサイズを気にする必要がない</li>
<li>行ごとの処理が楽 (<code>fgets</code> etc.)</li>
</ul>
</li>
</ul>


<h2>Programs and Processes</h2>

<ul>
<li><em>program</em> とは、ディレクトリにある実行可能なファイルのこと</li>
<li>program はメモリに読み込まれ、カーネルによって実行される</li>
<li>実行中のプログラムのことを <em>process</em> と呼ぶ

<ul>
<li><em>task</em> と呼んだりする OS もある</li>
</ul>
</li>
<li>UNIX は全てのプロセスにユニークな <em>process ID</em> を割り振る

<ul>
<li>process ID は non-negative な整数</li>
</ul>
</li>
<li>プロセス内で動いているスレッドは同じアドレス空間、ファイルディスクリプタ、スタック等のプロセスに関する属性を共有する

<ul>
<li>そのため、矛盾を起こさないように同期をとる必要がある</li>
</ul>
</li>
<li>スレッドは thread ID で管理される

<ul>
<li>thread ID はプロセスごとに閉じている</li>
</ul>
</li>
</ul>


<h2>Error Handling</h2>

<ul>
<li>UNIX システム関数でエラーが起こると、たいてい負の値が返り、<code>errno</code> と呼ばれる整数がセットされる

<ul>
<li><code>errno</code> が取りうる値は <code>&lt;errno.h&gt;</code> に定義されている</li>
<li>UNIX マニュアルの Section 2 の始め (<code>intro(2)</code>) で <code>errno</code> の説明が見れる

<ul>
<li>Linux では <code>errno(3)</code></li>
</ul>
</li>
</ul>
</li>
<li><code>errno</code> はエラーが起こらない限りクリアされないので、関数の戻り値を見てから <code>errno</code> を調べる必要がある</li>
<li><code>errno</code> に 0 がセットされることはない</li>
<li><code>strerror()</code> で <code>errno</code> に対応するエラーメッセージが取得できる</li>
<li><code>perror()</code> で引数に渡したメッセージと現在の <code>errno</code> に対応するエラーメッセージを standard error に出力できる</li>
<li><code>&lt;errno.h&gt;</code> に定義されたエラーは fatal なものと nonfatal なものに分かれる

<ul>
<li>fatal なエラーが起きた場合はエラーメッセージを出してプログラムを終了すべきである</li>
<li>リソース不足で起きるエラーなどが nonfatal なエラーに分類される</li>
<li>リソース関連の nonfatal エラーは <code>EAGAIN</code>, <code>ENFILE</code>, <code>ENOBUFS</code>, <code>ENOLCK</code>, <code>ENOSPC</code>, <code>ENOSR</code>, <code>EWOULDBLOCK</code>, <code>ENOMEM</code> など</li>
<li>リソース関連のエラーが起きた場合は少し待ってやり直すことで対応できることがある</li>
</ul>
</li>
</ul>


<h2>User Identification</h2>

<ul>
<li><em>user ID</em> はログイン名が作られたときに割り振られ、変更することはできない</li>
<li>user ID が 0 のユーザは <em>root</em> または <em>superuser</em> と呼ばれる</li>
<li><em>group ID</em> もログイン名が作られた時に割り振られる。</li>
<li>group name を group ID にマップするファイルが <code>/etc/group</code> にあり、group file と呼ばれる</li>
<li><code>getuid()</code> や <code>getgid()</code> で user ID や group ID が取れる</li>
<li>group ID の他に追加でグループに所属させることもできる (<em>supplementary group ID</em>)

<ul>
<li>16 個まで</li>
</ul>
</li>
</ul>


<h2>Signals</h2>

<ul>
<li>signal は何かが起きたことをプロセスに伝える手段

<ul>
<li>例えばゼロ除算が発生すると、<code>SIGFPE</code> がプロセスに送られる</li>
</ul>
</li>
<li>プロセスのシグナルの処理の仕方は 3 通りある

<ol>
<li>シグナルを無視する</li>
<li>デフォルトの動作を実行させる</li>
<li>シグナルが起きた時に呼ぶ関数を与える</li>
</ol>
</li>
<li>DELETE または Ctrl-C は <em>interrupt key</em>, Ctrl-backslash は <em>quit key</em> と呼ばれ、実行中のプロセスを終了させるのに使う</li>
<li><code>kill()</code> を呼ぶとシグナルを送ることができる</li>
<li>シグナルを送るためには、そのプロセスのオーナーでなければならない</li>
</ul>


<h2>Time Values</h2>

<ul>
<li>UNIX は2種類の時間を管理している

<ol>
<li>Calendar time: Epoch (UTC 1970 1/1 00:00:00) からの秒数

<ul>
<li><code>time_t</code> 型はこの値を持っている</li>
</ul>
</li>
<li>Process time: clock によって計測される

<ul>
<li>プロセスによって使われたリソースを計測するのに使う</li>
<li>CPU time ともいう</li>
<li><code>clock_t</code> 型がこの値を持っている</li>
</ul>
</li>
</ol>
</li>
<li>プロセスの実行時間を計測すると、3種類の値が得られる

<ul>
<li>Clock time: プロセスを実行するのにかかった時間

<ul>
<li>システム上で動いている他のプロセスの影響を受ける</li>
</ul>
</li>
<li>User CPU time: ユーザの命令が実行された時間（ループ処理など）</li>
<li>System CPU time: システムコールを行うのにかかった時間</li>
</ul>
</li>
<li>user CPU time と system CPU time を合わせて <em>CPU time</em> と呼ぶ</li>
</ul>


<h2>System Calls and Library Functions</h2>

<ul>
<li>system call のドキュメントは <em>UNIX Programmer's Manual</em> の Section 2 にある</li>
<li>Section 3 にはプログラマが普段使うであろう関数 (Library functions) の説明が書かれている (<code>printf()</code> etc.)

<ul>
<li>ライブラリ関数は複数のシステムコールの組み合わせでできている</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
</feed>
