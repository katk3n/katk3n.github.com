<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: lua | ApprEngineer.log]]></title>
  <link href="http://kentaktwo.github.com/blog/categories/lua/atom.xml" rel="self"/>
  <link href="http://kentaktwo.github.com/"/>
  <updated>2012-10-14T00:42:33+09:00</updated>
  <id>http://kentaktwo.github.com/</id>
  <author>
    <name><![CDATA[kentaktwo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Programming In Lua Chapter 2]]></title>
    <link href="http://kentaktwo.github.com/blog/2012/08/11/lua-chapter-2/"/>
    <updated>2012-08-11T20:50:00+09:00</updated>
    <id>http://kentaktwo.github.com/blog/2012/08/11/lua-chapter-2</id>
    <content type="html"><![CDATA[<h1>Types and Values</h1>

<!--more-->


<ul>
<li>Lua は動的型付け言語</li>
<li>Lua の基本型は以下の8つ:<br/>
<em>nil, boolean, number, string, userdata, function, thread, table</em></li>
<li>型を調べるには <code>type</code> 関数を使う</li>
</ul>


<h2>Nil</h2>

<ul>
<li>値でないことを表す</li>
<li>グローバル変数の初期値は <em>nil</em></li>
<li>変数を削除するには <em>nil</em> を代入する</li>
</ul>


<h2>Boolean</h2>

<ul>
<li><em>false</em> と <em>true</em> の2つ</li>
<li>Lua では、<em>false</em> と <em>nil</em> のみが false, 他は true</li>
</ul>


<h2>Numbers</h2>

<ul>
<li>C でいう double 型</li>
<li>Lua には integer 型は無い</li>
<li>32-bit の整数までなら丸め誤差無しで表現できる</li>
</ul>


<h2>Strings</h2>

<ul>
<li>Lua では string は immutable</li>
<li>メモリ管理は自動でやってくれる</li>
<li>ダブルクォートとシングルクォートどちらも使える</li>
<li>大カッコ2つで改行を含む文字列が扱える
<code>lua
block = [[
This is the
block string.
]]
</code></li>
<li>カッコの間に <code>=</code> を挟むと、同じ数の <code>=</code> が挟まれたカッコのところまで文字列になる。
<code>lua
block = [===[
This is the
block string.
a[b[i]]
]===]
</code></li>
<li>コメントでも使える
<code>lua
--[=[
This is
the comment.
a[b[i]]
]=]
</code></li>
<li>numbers と strings の変換は自動的にやってくれるが、数字と文字列の比較は false になる
<code>lua
print(10 == "10")  --&gt; false
</code></li>
<li>明示的に数値や文字列にしたい場合は <code>tonumber</code> や <code>tostring</code> 関数を使う</li>
<li><code>..</code> は文字列の連結
<code>lua
print(10 .. 20)  --&gt; 1020
</code></li>
<li>Lua 5.1 からは、'#' オペレータで文字列の長さが取れる
<code>lua
a = "hello"
print(#a)  --&gt; 5
</code></li>
</ul>


<h2>Tables</h2>

<ul>
<li>配列や連想配列を含む</li>
<li>モジュールやパッケージやオブジェクトも table で表現する</li>
<li>table は <code>{}</code> で初期化する
<code>lua
a = {}
a["x"] = 10
</code></li>
<li>table は参照（あるいはポインタ）として扱われる
<code>lua
a = {}
a["x"] = 10
b = a
b["x"] = 20
print(a["x"])  --&gt; 20
a = nil  -- b はまだ table を参照している
</code></li>
<li>グローバル変数と同様、定義されていないフィールドには <em>nil</em> が入っている</li>
<li><code>a.name</code> は <code>a["name"]</code> のこと。<code>a[name]</code> ではないので注意</li>
<li>Lua では配列のインデックスは 1 からスタート (0 ではない)</li>
<li>Lua 5.1 以降では、'#' オペレータで数字インデックスで最後に <em>nil</em> が入っていないものを返す
<code>lua
a = {}
a[10000] = 1  -- 1 から 9999 番目に nil が入る (hole)
print(#a)  --&gt; 0
a[1] = 1
print(#a)  --&gt; 1
</code></li>
<li>hole を含めて最後のインデックスを返したいときは <code>table.maxn</code> 関数を使う</li>
</ul>


<h2>Functions, Userdata, and Threads</h2>

<ul>
<li>Lua では関数も値として扱える。つまり変数に関数を入れられる。</li>
<li>userdata は C で書かれた新しい型を表現するのに使う</li>
<li>thread は coroutine を扱うのに使う</li>
<li>functions, userdata, threads は今後の章で詳しく扱う</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Programming In Lua Chapter 1]]></title>
    <link href="http://kentaktwo.github.com/blog/2012/07/24/lua-chapter-1/"/>
    <updated>2012-07-24T01:05:00+09:00</updated>
    <id>http://kentaktwo.github.com/blog/2012/07/24/lua-chapter-1</id>
    <content type="html"><![CDATA[<h1>Getting Started</h1>

<!--more-->


<p>Lua はスクリプト言語の一つで、非常にシンプルなことが特徴です。<br/>
組み込み系で使われることが多く、C 言語と簡単に連携することができます。<br/>
また、nmap の拡張スクリプト(NSE, Nmap Script Engine) も Lua で記述されています。</p>

<h2>Chunks</h2>

<ul>
<li>Lua を実行する1行の命令を <em>chunk</em> と呼ぶ</li>
<li>行末のセミコロンはオプション
<code>lua
a = 1; b = a*2;
a = 1  b = a*2  -- これでも OK
</code></li>
</ul>


<h2>Interactive Mode</h2>

<ul>
<li>引数を与えずに lua を実行するとインタラクティブモードで起動する

<ul>
<li>終了するときは <code>EOF</code> を送る (<code>ctrl-D</code>) か、<code>exit</code> 関数を呼ぶ:
``` lua

<blockquote><p>os.exit()
```</p></blockquote></li>
</ul>
</li>
<li><code>-i</code> オプションでファイルに書いてある chunk を実行してからインタラクティブモードを起動する
<code>sh
$ lua -i prog
</code></li>
<li><code>dofile</code> 関数を使ってもできる
``` lua

<blockquote><p>dofile("lib1.lua")  -- load your library
```</p></blockquote></li>
</ul>


<h2>Some Lexical Conventions</h2>

<ul>
<li>アンダースコアで始まり、大文字の変数名 (<code>_VERSION</code> など) は Lua 側で定義されているものが多いため、自分で定義するのは避けたほうがいい</li>
<li>Lua の予約語は非常に少ない</li>
<li><p>大文字と小文字は区別される。<code>and</code> は予約語だが、<code>And</code> や <code>AND</code> は使える</p></li>
<li><p>ハイフン2つ (<code>--</code>) でコメント</p></li>
<li><code>--[[</code> と <code>--]]</code> で挟むとブロックコメント
<code>lua
--[[
print(10)  -- 実行されない
--]]
</code></li>
<li>ハイフンを1つ付け足すだけでコメントを解除できる
<code>lua
---[[
print(10)  --&gt; 10
--]]
</code></li>
</ul>


<h2>Global Variables</h2>

<ul>
<li>グローバル変数を使うのに宣言する必要はない</li>
<li>グローバル変数は初期化しないと勝手に <code>nil</code> が入る
<code>
print(b)  --&gt; nil
b = 10
print(b)  --&gt; 10
</code></li>
<li>変数を消すには <code>nil</code> を代入する
<code>lua
b = nil
</code>
Lua では変数が存在するかどうかは、<code>nil</code> かどうかを調べることと同じになる</li>
</ul>


<h2>The Stand-Alone Interpreter</h2>

<p>Lua 起動時に
- <code>-e</code> オプションでコードを直接コマンドラインから動かせる
<code>sh
$ lua -e "print(math.sin(12))"
</code>
- <code>-l</code> オプションでライブラリを読み込む
``` sh</p>

<h1>a というライブラリを読み込み、x=10 を実行し、インタラクティブモードに入る</h1>

<p>$ lua -i -l a -e "x = 10"
<code>
- プロンプトは `_PROMPT` に定義されているのでそれを変えればプロンプトが変えられる
- インタラクティブモードでは、`=` を頭につけると結果を表示してくれる
</code> lua</p>

<blockquote><p>= math.sin(3)   --> math.sin(3) の値を表示
a = 30
= a             --> a の中身を表示
<code>``
- コマンドライン引数は</code>arg` というテーブルに格納される</p>

<pre><code>- スクリプト名は `arg[0]` に入る
- スクリプト名より先に引数を書くと、それらは負のインデックスに格納される
</code></pre>

<p><code>sh
$ lua -e "sin=math.sin" script a b
</code>
とすると
<code>lua
arg[-3] = "lua"
arg[-2] = "-e"
arg[-1] = "sin=math.sin"
arg[0] = "script"
arg[1] = "a"
arg[2] = "b"
</code>
になる。</p></blockquote>
]]></content>
  </entry>
  
</feed>
