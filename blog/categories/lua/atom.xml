<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: lua | ApprEngineer.log]]></title>
  <link href="http://kentaktwo.github.com/blog/categories/lua/atom.xml" rel="self"/>
  <link href="http://kentaktwo.github.com/"/>
  <updated>2013-05-01T23:22:46+09:00</updated>
  <id>http://kentaktwo.github.com/</id>
  <author>
    <name><![CDATA[kentaktwo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Programming in Lua Chapter 6]]></title>
    <link href="http://kentaktwo.github.com/blog/2013/05/01/lua-chapter-6/"/>
    <updated>2013-05-01T18:31:00+09:00</updated>
    <id>http://kentaktwo.github.com/blog/2013/05/01/lua-chapter-6</id>
    <content type="html"><![CDATA[<h1>More About Functions</h1>

<!--more-->


<ul>
<li>Lua の関数は JavaScript みたいに変数や table に入れたり、引数に渡したり、関数の戻り値として返すことができる。</li>
<li>Lua の関数は anonymous である
<code>lua
function foo(x) return 2*x end
</code>
は
<code>lua
foo = function(x) return 2*x end
</code>
の syntax suger である。</li>
</ul>


<h2>Closures</h2>

<ul>
<li>ある関数が他の関数の内部に書かれているとき、<br/>
その内部の関数はその内包している関数のローカル変数にアクセスすることができる (<em>lexical scoping</em>)。

<ul>
<li>そのローカル変数のことを <em>non-local variable</em> あるいは、Lua の世界では <em>upvalues</em> と呼ぶ。</li>
</ul>
</li>
<li>Lua の中では変数に入った関数は <em>closure</em> として振る舞う。
``` lua
function newCounter()
  local i = 0
  return function()  -- anonymous function

<pre><code>  i = i + 1
  return i
</code></pre>

<p>  end
end</p></li>
</ul>


<p>c1 = newCounter()
print(c1())  --> 1
print(c1())  --> 2
c2 = newCounter()
print(c2())  --> 1
print(c1())  --> 3
print(c2())  --> 2
```
関数自体は closure のプロトタイプのようなものである。</p>

<ul>
<li>関数を再定義することもできる。
<code>lua
oldSin = math.sin
math.sin = function(x)
  return oldSin(x*math.pi/180)
end
</code></li>
</ul>


<h2>Non-Global Functions</h2>

<ul>
<li><p>table のフィールドに関数を定義できる。
<code>lua
Lib = {}
Lib.foo = function(x,y) return x + y end
</code>
<code>lua
Lib = {
  foo = function(x,y) return x + y end
}
</code>
<code>lua
Lib = {}
function Lib.foo(x,y) return x + y end
</code></p></li>
<li><p>ローカル関数が定義できるが、再帰的に呼ぶときは注意。
<code>lua
local fact = function(n)
  if n == 0 then return 1
  else return n * fact(n-1)  -- does not work
  end
end
</code>
<code>fact(n-1)</code> が呼ばれる時点で <code>fact</code> はまだ定義されていないので、グローバル変数の fact が呼ばれてしまう。
先にローカル変数を宣言しておけばよい。
<code>lua
local fact
fact = function(n)    -- ここで local を書かないこと (新しくローカル変数が定義されてしまう)
  if n == 0 then return 1
  else return n * fact(n-1)
  end
end
</code>
ちなみに、
<code>lua
local function foo(&lt;params&gt;) &lt;body&gt; end
</code>
は
<code>lua
local foo
foo = function(&lt;params&gt;) &lt;body&gt; end
</code>
の syntax suger なので、この書き方をするなら上記のような心配はしなくてよい。</p></li>
</ul>


<h2>Proper Tail Calls</h2>

<ul>
<li>Lua は tail-call elimination (末尾呼出の最適化) を自動的に行う。

<ul>
<li>末尾再帰などで関数から関数を呼び出すときにスタックに積むのではなく、<br/>
goto 文にすることでスタックオーバーフローしないようにする。
<code>lua
-- これはスタックオーバーフローしない
function foo(n)
if n &gt; 0 then return foo(n - 1) end
end
</code></li>
</ul>
</li>
<li>tail-call elimination が有効になるのは、
<code>lua
return g(args)
</code>
の形のときのみで、以下のように g() の結果を使って何かしている場合は tail call ではない
<code>lua
function f(x) g(x) end                 -- return しない
function f(x) return g(x) + 1 end      -- f(x) が g(x) の結果に1を足している
function f(x) return (g(x)) end        -- f(x) が g(x) の結果を1つにまるめている
</code></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Programming In Lua Chapter 5]]></title>
    <link href="http://kentaktwo.github.com/blog/2013/04/30/lua-chapter-5/"/>
    <updated>2013-04-30T23:34:00+09:00</updated>
    <id>http://kentaktwo.github.com/blog/2013/04/30/lua-chapter-5</id>
    <content type="html"><![CDATA[<h1>Functions</h1>

<!--more-->


<ul>
<li>関数の引数が1つのみで、かつ引数が文字列リテラルまたは table のコンストラクタのときのみ、
関数の括弧を省略してよい。
<code>lua
print "Hello World"     -- print("Hello World")
f{x=10, y=20}           -- f({x=10, y=20})
</code></li>
<li>table obj の関数 foo() に対し、<code>obj:foo(x)</code> は <code>obj.foo(obj, x)</code> と同じ。<br/>
これはオブジェクト指向のような書き方をするときに使える。</li>
<li>関数の引数より少なく値が渡された場合は、値が渡されなかった引数には nil が入る。<br/>
また、引数より多く値が渡された場合は、余分な値は無視される。
<code>lua
function f(a, b)
  &lt;something&gt;
end
f(3, 4)     --&gt; a=3, b=4
f(3)        --&gt; a=3, b=nil
f(3, 4, 5)  --&gt; a=3, b=4 (5 は無視される)
</code></li>
</ul>


<h2>Multiple Results</h2>

<ul>
<li>Lua の関数は複数の値を返すことができる。
<code>lua
function foo() return "a", "b" end
x, y = foo()        -- x="a", y="b"
x = foo()           -- x="a"
x, y, z = foo()     -- x="a", y="b", z=nil
</code></li>
<li>複数の戻り値を受け取れるのは、その関数が文の中で最後に呼ばれたときのみ。
<code>lua
x, y, z = 10, foo()     -- x=10, y="a", z="b"
x. y, z = foo(), 10     -- x="a", y=10, z=nil
print(foo())            --&gt; a    b
print(foo(), 1)         --&gt; a    1
t = {foo(), 4}          -- t[1] = "a", t[2] = 4
</code></li>
<li>関数を余分に括弧で囲んで呼び出すと、戻り値を1つのみにすることができる。
<code>lua
print((foo()))          --&gt; a
</code></li>
</ul>


<h2>Variable Number of Arguments</h2>

<ul>
<li><code>...</code> で可変引数が扱える。
``` lua
function add(...)
  local s = 0
  for i, v in ipairs{...} do

<pre><code>  s = s + v
</code></pre>

<p>  end
  return s
end</p></li>
</ul>


<p>print(add(3, 4, 10, 25, 12))    --> 54
<code>
- printf() のような関数が書ける
</code> lua
function fwrite(fmt, ...)</p>

<pre><code>return io.write(string.format(fmt, ...))
</code></pre>

<p>end
```</p>

<h2>Named Arguments</h2>

<ul>
<li>Lua に <code>foo(x="a", y="b")</code> のように引数に名前をつけて関数を呼び出す機能は無いが、table を用いて似たようなことができる。
``` lua
function foo1(arg)
  return foo(arg.x, arg.y)
end</li>
</ul>


<p>foo1{x="a", y="b"}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Programming In Lua Chapter 4]]></title>
    <link href="http://kentaktwo.github.com/blog/2013/04/29/lua-chapter-4/"/>
    <updated>2013-04-29T23:48:00+09:00</updated>
    <id>http://kentaktwo.github.com/blog/2013/04/29/lua-chapter-4</id>
    <content type="html"><![CDATA[<h1>Statements</h1>

<!--more-->


<h2>Assignment</h2>

<ul>
<li>Lua は複数の変数への代入を同時にできる。
<code>lua
x, y = y, x  -- swap 'x' for 'y'
</code></li>
<li>変数の数の方が多かった場合、多かった分の変数には nil が入る。
``` lua
a, b, c = 0, 1
print(a, b, c)  --> 0  1  nil</li>
</ul>


<p>-- 初期化するときは注意
a, b, c = 0
print(a, b, c)  --> 0  nil  nil
<code>
- 代入値の方が多かった場合、多かった分の値は無視される。
</code> lua
a, b = 3, 4, 5
print(a, b)  --> 3  4
```</p>

<h2>Local Variables and Blocks</h2>

<ul>
<li>ローカル変数を使うには <code>local</code> を頭につけて宣言する。
<code>lua
j = 10          -- global variable
local i = 1     -- local variable
</code></li>
<li><code>do-end</code> を使ってブロックが作れる。
<code>lua
a = "foo"
do
  print(a)        --&gt; foo
  local a = 'bar'
  print(a)        --&gt; bar
end
print(a)            --&gt; foo
</code></li>
<li><code>local foo = foo</code> とすれば、グローバル変数の foo を変えずにローカル変数の foo を操作できる。</li>
<li>ローカル変数の方がアクセスがスコープが限定されていて、アクセスも速いので、できるだけローカル変数を使うようにする。</li>
</ul>


<h2>Control Structures</h2>

<h3>if then else</h3>

<p>``` lua
if op == "+" then</p>

<pre><code>r = a + b
</code></pre>

<p>elseif op == "-" then</p>

<pre><code>r = a - b
</code></pre>

<p>else</p>

<pre><code>r = nil
</code></pre>

<p>end
<code>``
-</code>else if<code>ではなく</code>elseif`</p>

<h3>while</h3>

<p><code>while-do-end</code> の形で使う</p>

<h3>repeat</h3>

<p>C 言語でいう do-while みたいなやつ
``` lua
repeat</p>

<pre><code>line = os.read()
</code></pre>

<p>until line ~= ""
print(line)
```
- 他の多くのプログラミング言語と違い、repeat 内のローカル変数は until の中でも有効。</p>

<h3>Numeric for</h3>

<p>``` lua
-- i=10 から始めて、1 まで -1 刻みで <something> をする。
for i=10, 1, -1 do</p>

<pre><code>&lt;something&gt;
</code></pre>

<p>end</p>

<p>-- 3つ目を省略すると 1 刻みになる。
for i=1, #a do</p>

<pre><code>a[i] = a[i] + 1     -- すべての a[i] に1をたす
</code></pre>

<p>end
<code>``
-</code>break` が使える。</p>

<h3>Generic for</h3>

<p>イテレータ関数を使って要素を回す
``` lua
-- 配列 'a' の全要素を表示する
for i, v in ipairs(a) do</p>

<pre><code>print(v)
</code></pre>

<p>end
```</p>

<h2>break and return</h2>

<ul>
<li><code>break</code> と <code>return</code> が使える。</li>
<li><code>end</code>, <code>else</code>, <code>until</code> のいずれかの直前にしか置いてはいけない。
<code>lua
function foo()
  return          --&lt;&lt; SYNTAX ERROR
  &lt;something&gt;
end
</code>
デバッグ用途などで return を書きたい場合は、<code>do-end</code> を使う。
<code>lua
function foo()
  do return end  -- end の直前にあるので OK
  &lt;something&gt;
end
</code></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Programming In Lua Chapter 3]]></title>
    <link href="http://kentaktwo.github.com/blog/2013/04/29/lua-chapter-3/"/>
    <updated>2013-04-29T23:04:00+09:00</updated>
    <id>http://kentaktwo.github.com/blog/2013/04/29/lua-chapter-3</id>
    <content type="html"><![CDATA[<h1>Expressions</h1>

<!--more-->


<h2>Arithmetic Operations</h2>

<p>Lua がサポートしている演算子は<br/>
<code>+</code>, <code>-</code> (二項演算子), <code>*</code>, <code>/</code>, <code>^</code> (累乗), <code>%</code>, <code>-</code> (単項演算子)</p>

<p><code>%</code> の定義は
<code>lua
a % b == a - floor(a/b)*b
</code>
<code>%</code> 演算子は小数でも有効で、例えば <code>x - x%0.01</code> とすれば、<code>x</code> の小数第二位までが取れる。</p>

<h2>Relational Operators</h2>

<p>Lua の比較演算子は、型の一致も含めてチェックする。<br/>
よって <code>1 == "1"</code> は false。<br/>
ちなみに "等しくない" は <code>!=</code> ではなく <code>~=</code>。<br/>
table, userdata, function の比較は参照単位で行われる。
``` lua</p>

<blockquote><p>a = {}; a.x = 1; a.y = 0
b = {}; b.x = 1; b.y = 0
c = a
= a == b  --> false
= a == c  --> true
<code>``
</code>2 &lt; "15"` のように型が違う値の大小関係を調べようとするとエラーになる。</p></blockquote>

<h2>Logical Operators</h2>

<p><code>and</code>, <code>or</code>, <code>not</code> がある。<br/>
<code>x and y</code> は、x が true なら y, false なら x<br/>
<code>x or y</code> は、x が true なら x, false なら y</p>

<p><code>lua
x = x or v
</code>
は <code>if not x then x = v end</code> と同じで、x にデフォルト値を入れるときなどに使える。</p>

<p><code>lua
(a and b) or c
</code>
で、C 言語の <code>a ? b : c</code> と同じことができる。</p>

<h2>Table Constructors</h2>

<p>table を作るときに初期値が入れられる。index は 1 始まり。
``` lua
--[[
t1[1] = "a" (t[0] ではない)
t1[2] = "b"
t1[3] = "c"
t1["x"] = "d" (t.x = "d")
t1["y"] = "e" (t.y = "e")
--]]
t1 = {"a", "b", "c", x="d", y="e"}</p>

<p>--[[
[] を使うと複雑な index も作れる
{["x"] = 0} と {x=0} は同じ</p>

<p>t2[-1] = "a"
t2["+"] = "add"
t[22] = "s"
--]]
i = 20
t2 = {[-1] = "a", ["+"] = "add", [i+2] = "s"}</p>

<p>--[[
0 始まりの table を作ることもできるが、
ほとんどの関数等は 1 始まりを想定して作られているのでやめたほうがいい。
--]]
t3 = {[0]="a", "b", "c", "d"}</p>

<p>--[[
要素の区切りにカンマの代わりにセミコロンが使える。
--]]
t4 = {x=10, y=45; "one", "two", "three"}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Programming In Lua Chapter 2]]></title>
    <link href="http://kentaktwo.github.com/blog/2012/08/11/lua-chapter-2/"/>
    <updated>2012-08-11T20:50:00+09:00</updated>
    <id>http://kentaktwo.github.com/blog/2012/08/11/lua-chapter-2</id>
    <content type="html"><![CDATA[<h1>Types and Values</h1>

<!--more-->


<ul>
<li>Lua は動的型付け言語</li>
<li>Lua の基本型は以下の8つ:<br/>
<em>nil, boolean, number, string, userdata, function, thread, table</em></li>
<li>型を調べるには <code>type</code> 関数を使う</li>
</ul>


<h2>Nil</h2>

<ul>
<li>値でないことを表す</li>
<li>グローバル変数の初期値は <em>nil</em></li>
<li>変数を削除するには <em>nil</em> を代入する</li>
</ul>


<h2>Boolean</h2>

<ul>
<li><em>false</em> と <em>true</em> の2つ</li>
<li>Lua では、<em>false</em> と <em>nil</em> のみが false, 他は true</li>
</ul>


<h2>Numbers</h2>

<ul>
<li>C でいう double 型</li>
<li>Lua には integer 型は無い</li>
<li>32-bit の整数までなら丸め誤差無しで表現できる</li>
</ul>


<h2>Strings</h2>

<ul>
<li>Lua では string は immutable</li>
<li>メモリ管理は自動でやってくれる</li>
<li>ダブルクォートとシングルクォートどちらも使える</li>
<li>大カッコ2つで改行を含む文字列が扱える
<code>lua
block = [[
This is the
block string.
]]
</code></li>
<li>カッコの間に <code>=</code> を挟むと、同じ数の <code>=</code> が挟まれたカッコのところまで文字列になる。
<code>lua
block = [===[
This is the
block string.
a[b[i]]
]===]
</code></li>
<li>コメントでも使える
<code>lua
--[=[
This is
the comment.
a[b[i]]
]=]
</code></li>
<li>numbers と strings の変換は自動的にやってくれるが、数字と文字列の比較は false になる
<code>lua
print(10 == "10")  --&gt; false
</code></li>
<li>明示的に数値や文字列にしたい場合は <code>tonumber</code> や <code>tostring</code> 関数を使う</li>
<li><code>..</code> は文字列の連結
<code>lua
print(10 .. 20)  --&gt; 1020
</code></li>
<li>Lua 5.1 からは、'#' オペレータで文字列の長さが取れる
<code>lua
a = "hello"
print(#a)  --&gt; 5
</code></li>
</ul>


<h2>Tables</h2>

<ul>
<li>配列や連想配列を含む</li>
<li>モジュールやパッケージやオブジェクトも table で表現する</li>
<li>table は <code>{}</code> で初期化する
<code>lua
a = {}
a["x"] = 10
</code></li>
<li>table は参照（あるいはポインタ）として扱われる
<code>lua
a = {}
a["x"] = 10
b = a
b["x"] = 20
print(a["x"])  --&gt; 20
a = nil  -- b はまだ table を参照している
</code></li>
<li>グローバル変数と同様、定義されていないフィールドには <em>nil</em> が入っている</li>
<li><code>a.name</code> は <code>a["name"]</code> のこと。<code>a[name]</code> ではないので注意</li>
<li>Lua では配列のインデックスは 1 からスタート (0 ではない)</li>
<li>Lua 5.1 以降では、'#' オペレータで数字インデックスで最後に <em>nil</em> が入っていないものを返す
<code>lua
a = {}
a[10000] = 1  -- 1 から 9999 番目に nil が入る (hole)
print(#a)  --&gt; 0
a[1] = 1
print(#a)  --&gt; 1
</code></li>
<li>hole を含めて最後のインデックスを返したいときは <code>table.maxn</code> 関数を使う</li>
</ul>


<h2>Functions, Userdata, and Threads</h2>

<ul>
<li>Lua では関数も値として扱える。つまり変数に関数を入れられる。</li>
<li>userdata は C で書かれた新しい型を表現するのに使う</li>
<li>thread は coroutine を扱うのに使う</li>
<li>functions, userdata, threads は今後の章で詳しく扱う</li>
</ul>

]]></content>
  </entry>
  
</feed>
