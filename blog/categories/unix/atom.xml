<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: unix | ApprEngineer.log]]></title>
  <link href="http://kentaktwo.github.com/blog/categories/unix/atom.xml" rel="self"/>
  <link href="http://kentaktwo.github.com/"/>
  <updated>2012-04-29T01:29:47+09:00</updated>
  <id>http://kentaktwo.github.com/</id>
  <author>
    <name><![CDATA[kentaktwo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Advanced Programming in the UNIX environment Chapter 1]]></title>
    <link href="http://kentaktwo.github.com/blog/2012/04/28/apue-chapter-1/"/>
    <updated>2012-04-28T22:45:00+09:00</updated>
    <id>http://kentaktwo.github.com/blog/2012/04/28/apue-chapter-1</id>
    <content type="html"><![CDATA[<h1>UNIX System Overview</h1>

<!--more-->


<h2>UNIX Architecture</h2>

<ul>
<li>OS (Operating System) とは、コンピュータのハードウェアを制御し、プログラムが動作する環境を提供するソフトウェアのこと</li>
<li>このソフトウェアのことを <em>kernel</em> と呼ぶ</li>
<li>kernel とのインターフェースとなるソフトウェア群を <em>system calls</em> と呼ぶ</li>
<li>shell は他のアプリケーションを動かすためのインターフェースとなるアプリケーション</li>
</ul>


<h2>Logging In</h2>

<ul>
<li>ログイン名は たいてい <code>/etc/passwd</code> に書かれている
``` sh

<h1>最近はパスワードは別ファイルになっていることが多い</h1>

<p><loginName>:<encryptedPassword>:<userID>:<groupID>:<comment>:<homeDirectory>:<shellProgram>
```</p></li>
</ul>


<h2>Files and Directories</h2>

<ul>
<li><em>directory</em> とは directory entries を含んだファイルのこと</li>
<li>directory の中にある名前を <em>filename</em> という

<ul>
<li>filename には <code>/</code> と null 文字以外の全ての文字が使える</li>
</ul>
</li>
<li>UNIX のマニュアルは section 1 から 8 まである

<ul>
<li>ls は Section 1 にある</li>
</ul>
</li>
</ul>


<h2>Input and Output</h2>

<ul>
<li>File descriptors とは、カーネルがプロセスからアクセスされるファイルを識別するための non-negative な整数のこと</li>
<li>Unbuffered I/O は <code>open</code>, <code>read</code>, <code>write</code>, <code>lseek</code>, <code>close</code> によって提供される</li>
<li>Standard I/O は unbuffered I/O にバッファインターフェースを提供する

<ul>
<li>バッファサイズを気にする必要がない</li>
<li>行ごとの処理が楽 (<code>fgets</code> etc.)</li>
</ul>
</li>
</ul>


<h2>Programs and Processes</h2>

<ul>
<li><em>program</em> とは、ディレクトリにある実行可能なファイルのこと</li>
<li>program はメモリに読み込まれ、カーネルによって実行される</li>
<li>実行中のプログラムのことを <em>process</em> と呼ぶ

<ul>
<li><em>task</em> と呼んだりする OS もある</li>
</ul>
</li>
<li>UNIX は全てのプロセスにユニークな <em>process ID</em> を割り振る

<ul>
<li>process ID は non-negative な整数</li>
</ul>
</li>
<li>プロセス内で動いているスレッドは同じアドレス空間、ファイルディスクリプタ、スタック等のプロセスに関する属性を共有する

<ul>
<li>そのため、矛盾を起こさないように同期をとる必要がある</li>
</ul>
</li>
<li>スレッドは thread ID で管理される

<ul>
<li>thread ID はプロセスごとに閉じている</li>
</ul>
</li>
</ul>


<h2>Error Handling</h2>

<ul>
<li>UNIX システム関数でエラーが起こると、たいてい負の値が返り、<code>errno</code> と呼ばれる整数がセットされる

<ul>
<li><code>errno</code> が取りうる値は <code>&lt;errno.h&gt;</code> に定義されている</li>
<li>UNIX マニュアルの Section 2 の始め (<code>intro(2)</code>) で <code>errno</code> の説明が見れる

<ul>
<li>Linux では <code>errno(3)</code></li>
</ul>
</li>
</ul>
</li>
<li><code>errno</code> はエラーが起こらない限りクリアされないので、関数の戻り値を見てから <code>errno</code> を調べる必要がある</li>
<li><code>errno</code> に 0 がセットされることはない</li>
<li><code>strerror()</code> で <code>errno</code> に対応するエラーメッセージが取得できる</li>
<li><code>perror()</code> で引数に渡したメッセージと現在の <code>errno</code> に対応するエラーメッセージを standard error に出力できる</li>
<li><code>&lt;errno.h&gt;</code> に定義されたエラーは fatal なものと nonfatal なものに分かれる

<ul>
<li>fatal なエラーが起きた場合はエラーメッセージを出してプログラムを終了すべきである</li>
<li>リソース不足で起きるエラーなどが nonfatal なエラーに分類される</li>
<li>リソース関連の nonfatal エラーは <code>EAGAIN</code>, <code>ENFILE</code>, <code>ENOBUFS</code>, <code>ENOLCK</code>, <code>ENOSPC</code>, <code>ENOSR</code>, <code>EWOULDBLOCK</code>, <code>ENOMEM</code> など</li>
<li>リソース関連のエラーが起きた場合は少し待ってやり直すことで対応できることがある</li>
</ul>
</li>
</ul>


<h2>User Identification</h2>

<ul>
<li><em>user ID</em> はログイン名が作られたときに割り振られ、変更することはできない</li>
<li>user ID が 0 のユーザは <em>root</em> または <em>superuser</em> と呼ばれる</li>
<li><em>group ID</em> もログイン名が作られた時に割り振られる。</li>
<li>group name を group ID にマップするファイルが <code>/etc/group</code> にあり、group file と呼ばれる</li>
<li><code>getuid()</code> や <code>getgid()</code> で user ID や group ID が取れる</li>
<li>group ID の他に追加でグループに所属させることもできる (<em>supplementary group ID</em>)

<ul>
<li>16 個まで</li>
</ul>
</li>
</ul>


<h2>Signals</h2>

<ul>
<li>signal は何かが起きたことをプロセスに伝える手段

<ul>
<li>例えばゼロ除算が発生すると、<code>SIGFPE</code> がプロセスに送られる</li>
</ul>
</li>
<li>プロセスのシグナルの処理の仕方は 3 通りある

<ol>
<li>シグナルを無視する</li>
<li>デフォルトの動作を実行させる</li>
<li>シグナルが起きた時に呼ぶ関数を与える</li>
</ol>
</li>
<li>DELETE または Ctrl-C は <em>interrupt key</em>, Ctrl-backslash は <em>quit key</em> と呼ばれ、実行中のプロセスを終了させるのに使う</li>
<li><code>kill()</code> を呼ぶとシグナルを送ることができる</li>
<li>シグナルを送るためには、そのプロセスのオーナーでなければならない</li>
</ul>


<h2>Time Values</h2>

<ul>
<li>UNIX は2種類の時間を管理している

<ol>
<li>Calendar time: Epoch (UTC 1970 1/1 00:00:00) からの秒数

<ul>
<li><code>time_t</code> 型はこの値を持っている</li>
</ul>
</li>
<li>Process time: clock によって計測される

<ul>
<li>プロセスによって使われたリソースを計測するのに使う</li>
<li>CPU time ともいう</li>
<li><code>clock_t</code> 型がこの値を持っている</li>
</ul>
</li>
</ol>
</li>
<li>プロセスの実行時間を計測すると、3種類の値が得られる

<ul>
<li>Clock time: プロセスを実行するのにかかった時間

<ul>
<li>システム上で動いている他のプロセスの影響を受ける</li>
</ul>
</li>
<li>User CPU time: ユーザの命令が実行された時間（ループ処理など）</li>
<li>System CPU time: システムコールを行うのにかかった時間</li>
</ul>
</li>
<li>user CPU time と system CPU time を合わせて <em>CPU time</em> と呼ぶ</li>
</ul>


<h2>System Calls and Library Functions</h2>

<ul>
<li>system call のドキュメントは <em>UNIX Programmer's Manual</em> の Section 2 にある</li>
<li>Section 3 にはプログラマが普段使うであろう関数 (Library functions) の説明が書かれている (<code>printf()</code> etc.)

<ul>
<li>ライブラリ関数は複数のシステムコールの組み合わせでできている</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[BackTrack 5 RC2 をインストール]]></title>
    <link href="http://kentaktwo.github.com/blog/2012/04/17/install-backtrack/"/>
    <updated>2012-04-17T21:49:00+09:00</updated>
    <id>http://kentaktwo.github.com/blog/2012/04/17/install-backtrack</id>
    <content type="html"><![CDATA[<p>ペネトレーションテストに特化した Linux ディストリビューションの BackTrack をインストールしました。</p>

<p><a href="http://www.backtrack-linux.org/">http://www.backtrack-linux.org/</a></p>

<!--more-->


<h2>BackTrack とは</h2>

<ul>
<li>Ubuntu がベース (BackTrack4 以降)</li>
<li>様々なセキュリティツールが入っている</li>
</ul>


<h2>インストール</h2>

<p>Virtual Box にインストールした。</p>

<ul>
<li>OS タイプは Ubuntu 64 bit</li>
<li>NAT + ホストオンリーアダプタ</li>
</ul>


<p>起動したら root/toor で root にログインして、</p>

<pre><code>$ startx
</code></pre>

<p>で GUI を起動する。</p>

<h2>設定</h2>

<h3>ユーザの追加</h3>

<pre><code>$ adduser &lt;username&gt;
</code></pre>

<p>useradd だとホームディレクトリの作成や設定のコピー等をやってくれない</p>

<h3>sudo の設定</h3>

<pre><code>$ visudo
</code></pre>

<p>エディタは vi でないので注意。</p>

<pre><code>%&lt;username&gt; ALL=(ALL) ALL
</code></pre>

<p>を追加。</p>

<h3>host 名の変更</h3>

<pre><code>$ sudo vi /etc/hostname
$ sudo vi /etc/hosts
</code></pre>

<h3>IP の設定</h3>

<p>eth1 の部分を以下のように編集
``` sh /etc/network/interfaces
auto eth1
iface eth1 inet static</p>

<pre><code>address 192.168.56.121
netmask 255.255.255.0
network 192.168.56.0
broadcast 192.168.56.255
</code></pre>

<p>```</p>

<h3>ssh の設定</h3>

<pre><code>$ sudo apt-get --purge remove openssh-server
$ sudo apt-get install openssh-server
</code></pre>

<p>``` sh /etc/ssh/sshd_config</p>

<h1>root でのログインを無効にする</h1>

<p>PermitRootLogin no</p>

<h1>パスワード認証を一時的に有効にする</h1>

<p>PasswordAuthentication yes
```</p>

<p>sshd 再起動</p>

<pre><code>$ sudo /etc/init.d/ssh restart
$ sudo lsof -nPi:22  # 確認
</code></pre>

<p>鍵の設定が終わったら、PasswordAuthentication を no に戻しておく。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[FreeBSD のセットアップ]]></title>
    <link href="http://kentaktwo.github.com/blog/2012/01/26/freebsd-setup/"/>
    <updated>2012-01-26T00:16:00+09:00</updated>
    <id>http://kentaktwo.github.com/blog/2012/01/26/freebsd-setup</id>
    <content type="html"><![CDATA[<p>FreeBSD 9.0 のインストールとか設定とか</p>

<!--more-->


<h2>FreeBSD 9.0 のインストール</h2>

<p>FreeBSD 9.x 以降では bsdinstall と呼ばれるインストールプログラムを使う。<br/>
以下を見ながらインストール<br/>
<a href="http://www.freebsd.org/doc/ja_JP.eucJP/books/handbook/bsdinstall.html">http://www.freebsd.org/doc/ja_JP.eucJP/books/handbook/bsdinstall.html</a></p>

<h2>ホスト名の変更</h2>

<pre><code>$ hostname "ホスト名"
</code></pre>

<p>で一時的に変更できるが、OS を再起動すると元に戻ってしまうため、<br/>
<code>/etc/hosts</code>, <code>/etc/resolv.conf</code>, <code>/etc/rc.conf</code> の設定も直しておく (Linux の場合は <code>/etc/sysconfig/network</code>)</p>

<h2>ports からパッケージのインストール</h2>

<h3>ports ツリーの構成</h3>

<pre><code>$ pkg_add -r portsnap  # portsnap が無い場合まず package からインストールする
$ portsnap fetch
$ portsnap extract
$ portsnap update
</code></pre>

<p>ports にあるパッケージは <code>/usr/ports/</code> 以下にカテゴリ別に置かれている。<br/>
<a href="http://www.freebsd.org/cgi/ports.cgi">http://www.freebsd.org/cgi/ports.cgi</a><br/>
からパッケージの検索ができる。<br/>
また、</p>

<pre><code>$ whereis &lt;package name&gt;
</code></pre>

<p>でどこのパッケージがあるか探すことができる。</p>

<h3>sudo</h3>

<p>FreeBSD には デフォルトで sudo は入っていない</p>

<pre><code>$ su root
# cd /usr/ports/security/sudo
# make install clean
</code></pre>

<p>インストール後 visudo で sudoers を編集</p>

<h3>portaudit</h3>

<p>パッケージのセキュリティに関する脆弱性を調べる</p>

<pre><code>$ cd /usr/ports/ports-mgmt/portaudit
$ sudo make install clean
$ portaudit -F
</code></pre>

<h3>portupgrade</h3>

<p>portinstall, portupgrade 等が使えるようになる</p>

<pre><code>$ cd /usr/ports/ports-mgmt/portsupgrade
$ sudo make install clean
</code></pre>

<h3>ports package の設定をやり直す</h3>

<pre><code>$ sudo make config
</code></pre>

<h3>ports package のアンインストール</h3>

<pre><code>$ sudo make deinstall
</code></pre>

<h3>ports package の再インストール</h3>

<pre><code>$ sudo make reinstall
</code></pre>

<h2>login 時の shell の設定</h2>

<pre><code>$ chsh -s /usr/local/bin/zsh
</code></pre>

<h2>httpd 起動のための設定</h2>

<p>accept filter を使うために <code>accf_http.ko</code> というカーネルモジュールを読み込む必要がある。</p>

<pre><code>$ sudo kldload accf_http.ko
</code></pre>

<p>OS 起動時に読み込ませるには、<code>/boot/loader.conf</code> に</p>

<pre><code>accf_http_load="YES"
</code></pre>

<p>を追加する。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[VirtualBox に入れたゲスト OS に ssh login]]></title>
    <link href="http://kentaktwo.github.com/blog/2012/01/25/vbox-portforwarding/"/>
    <updated>2012-01-25T23:51:00+09:00</updated>
    <id>http://kentaktwo.github.com/blog/2012/01/25/vbox-portforwarding</id>
    <content type="html"><![CDATA[<p>家の Mac OS X の VirtualBox に FreeBSD 9.0 を入れました。<br/>
Host から Guest に ssh する設定をしました。</p>

<!-- more -->


<h2>ゲスト OS のポートフォワーディング設定</h2>

<pre><code># ssh の設定
$ VBoxManage setextradata "f1" "VBoxInternal/Devices/e1000/0/LUN#0/Config/guestssh/Protocol" TCP
$ VBoxManage setextradata "f1" "VBoxInternal/Devices/e1000/0/LUN#0/Config/guestssh/GuestPort" 22
$ VBoxManage setextradata "f1" "VBoxInternal/Devices/e1000/0/LUN#0/Config/guestssh/HostPort" 60022

# http の設定
$ VBoxManage setextradata "f1" "VBoxInternal/Devices/e1000/0/LUN#0/Config/guesthttp/Protocol" TCP
$ VBoxManage setextradata "f1" "VBoxInternal/Devices/e1000/0/LUN#0/Config/guesthttp/GuestPort" 80
$ VBoxManage setextradata "f1" "VBoxInternal/Devices/e1000/0/LUN#0/Config/guesthttp/HostPort" 60080
</code></pre>

<ul>
<li>Guest の 22 番ポートを Host の 60022 番ポートへ</li>
<li>Guest の 80 番ポートを Host の 60080 番ポートへ</li>
</ul>


<p>転送する。f1 は VM の名前。<br/>
自由に使用できるポート番号は 49152 〜 65535 らしい。
50000 番台は CentOS が使っているので、FreeBSD は 60000 番台に割り当てました。</p>

<h2>ゲスト OS の起動</h2>

<pre><code>$ VBoxManage startvm --type vrdp f1
</code></pre>

<h2>ゲスト OS に ssh</h2>

<pre><code>$ ssh -p 60022 localhost
</code></pre>

<h2>ゲスト OS に scp</h2>

<pre><code>$ scp -P 60022 file username@localhost:/home/uername/path
</code></pre>
]]></content>
  </entry>
  
</feed>
