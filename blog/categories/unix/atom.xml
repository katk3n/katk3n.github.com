<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: unix | ApprEngineer.log]]></title>
  <link href="http://kentaktwo.github.com/blog/categories/unix/atom.xml" rel="self"/>
  <link href="http://kentaktwo.github.com/"/>
  <updated>2013-01-07T00:47:58+09:00</updated>
  <id>http://kentaktwo.github.com/</id>
  <author>
    <name><![CDATA[kentaktwo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Advanced Programming in the UNIX enviroment Chapter 4]]></title>
    <link href="http://kentaktwo.github.com/blog/2012/10/14/apue-chapter-4/"/>
    <updated>2012-10-14T14:25:00+09:00</updated>
    <id>http://kentaktwo.github.com/blog/2012/10/14/apue-chapter-4</id>
    <content type="html"><![CDATA[<h1>Files and Directories</h1>

<!--more-->


<h2>stat, fstat and lstat Functions</h2>

<p>``` c</p>

<h1>include &lt;sys/stat.h></h1>

<p>int stat(const char <em>restrict pathname, struct stat </em>restrict buf);
int fstat(int filedes, struct stat <em>buf);
int lstat(const char </em>restrict pathname, struct stat *restrict buf);</p>

<p>return 0 if OK, -1 on error
```</p>

<ul>
<li>ファイルについての情報が書かれた構造体 (stat 構造体) を返す。

<ul>
<li><code>stat()</code> はファイル名</li>
<li><code>fstat()</code> はファイルディスクリプタ</li>
<li><code>lstat()</code> はシンボリックリンク
(<code>stat()</code> の場合はシンボリックリンクのときはその参照先)</li>
</ul>
</li>
<li>restrict ポインタはそのポインタが別名を持たないことを保証し、
コンパイル時の最適化を効率的に行うことができる。</li>
<li>stat 構造体の定義は実装によるが、だいたい以下のようになる</li>
</ul>


<p>``` c
struct stat {</p>

<pre><code>mode_t      st_mode;    /* file type &amp; mode (permissions) */
ino_t       st_ino;     /* i-node number (serial number) */
dev_t       st_dev;     /* device number (file system) */
dev_t       st_rdev;    /* device number for special files */
nlink_t     st_nlink;   /* number of links */
uid_t       st_uid;     /* user ID of owner */
gid_t       st_gid;     /* group ID of owner */
off_t       st_size;    /* size in bytes, for regular files */
time_t      st_atime;   /* time of last access */
time_t      st_mtime;   /* time of last modification */
time_t      st_ctime;   /* time of last file status change */
blksize_t   st_blksize; /* best I/O block size */
blkcnt_t    st_blocks;  /* number of disk blocks allocated */
</code></pre>

<p>};
```</p>

<h2>File Types</h2>

<ul>
<li>ファイルの種類は7種類

<ul>
<li>Regular file</li>
<li>Directory file</li>
<li>Block special file: ディスクドライブなどのデバイスに buffered I/O アクセスする</li>
<li>Character special file: デバイスに unbuffered I/O アクセスする</li>
<li>FIFO: プロセス間通信で使う。pipe とも呼ばれる。</li>
<li>Socket: プロセス間のネットワーク通信に使う。</li>
<li>Symbolic link: 他のファイルを参照するファイル</li>
</ul>
</li>
<li>ファイルの種類は <code>st_mode</code> に入っている。</li>
<li>ファイルの種類を調べるには <code>S_ISREG()</code>, <code>S_ISDIR()</code> などのマクロを使う。

<ul>
<li>Linux で <code>S_ISSOCK()</code> マクロを使うには <code>_GNU_SOURCE</code> を定義する必要がある。</li>
</ul>
</li>
</ul>


<h2>Set-User-ID and Set-Group-ID</h2>

<ul>
<li>すべてのプロセスは関連する ID を持っている

<ul>
<li>real user ID, real group ID<br/>
自分が誰なのかを表す。login 時に password file から読み取られる。</li>
<li>effective user ID, effective group ID, supplementary group ID<br/>
ファイルアクセスの権限を表す。</li>
<li>saved set-user-ID, saved set-group-ID<br/>
プログラム実行時の effective user ID と effective group ID のコピー</li>
</ul>
</li>
<li>プログラムが実行されると、通常 effective user (group) ID には real user (group) ID がセットされるが、
<em>set-user-ID</em> bit や <em>set-group-ID</em> bit を立てると、
effective user (group) ID をそのファイルのオーナー (<code>st_uid</code>, <code>st_gid</code>) にすることができる。

<ul>
<li><code>passwd(1)</code> はスーパーユーザーで実行される必要がある。</li>
</ul>
</li>
<li>set-user-ID (set-group-ID) bit は<code>st_mode</code> の中に含まれ、<code>S_ISUID()</code>, <code>S_ISGID()</code> で調べることができる。</li>
</ul>


<h2>File Access Permissions</h2>

<ul>
<li>directory の execute 権限は search bit とも呼ばれる

<ul>
<li>directory の read 権限は directory 内のファイル名のリストを表示したりする (directory file を読む) 権限</li>
<li>directory の execute 権限は directory にアクセスする権限</li>
</ul>
</li>
<li>ファイルを削除するには、そのファイルがある directory に write と execute 権限があることが必要。
そのファイル自体に read や write 権限がある必要はない。</li>
<li>owner ID はファイルのプロパティであり、effective ID はプロセスのプロパティである。</li>
</ul>


<h2>access Function</h2>

<p>``` c</p>

<h1>include &lt;unistd.h></h1>

<p>int access(const char *pathname, int mode);</p>

<p>return 0 if OK, -1 on error
```</p>

<ul>
<li>(effective でなく) real user (group) ID がファイルへの権限を持っているか調べる。</li>
<li>set-user-ID されていても、real user ID についての権限が調べられる。</li>
</ul>


<h2>umask Function</h2>

<p>``` c</p>

<h1>include &lt;sys/stat.h></h1>

<p>mode_t umask(mode_t cmask);</p>

<p>return: 変更前の mask
```
- ファイル作成時に umask に設定した権限を除外することができる。</p>

<pre><code>- `S_IROTH | S_IWOTH` みたいにして設定
</code></pre>

<ul>
<li>プログラム内で設定した umask はプログラムが終了すると元に戻る。</li>
</ul>


<h2>chmod and fchmod Functions</h2>

<p>``` c</p>

<h1>include &lt;sys/stat.h></h1>

<p>int chmod(const char *pathname, mode_t mode);
int fchmod(int filedes, mode_t mode);</p>

<p>return 0 if OK, -1 on error
```</p>

<ul>
<li>ファイルのアクセス権限を変更する。</li>
<li>現在の権限から group execute 権限を取り除き、set-group-ID するには</li>
</ul>


<p><code>c
struct stat statbuf;
stat("foo", &amp;statbuf);
chmod("foo", (statbuf.st_mode &amp; ~S_IXGRP) | S_ISGID);
</code></p>

<ul>
<li><code>ls -l</code> したときに execute 権限にある <code>S</code> は execute 権限は無いが、
set-user-ID (set-group-ID) されてるという意味。</li>
</ul>


<h2>Sticky Bit</h2>

<ul>
<li>sticky bit がセットされたプログラムが実行されると、
プロセス終了時にそのコピーがスワップ領域にコピーされる。</li>
<li>次回以降そのプログラム実行時のメモリへのロードが高速になる。</li>
<li>sticky bit をセットにするには <code>S_ISVTX</code> をセットする。</li>
<li>最近の UNIX システムでは <em>saved-text</em> bit と呼ばれる。</li>
<li>最近の UNIX システムでは Virtual memory システムだったり、ファイルシステムが高速
になったりで、このテクニックの必要は薄くなっている。</li>
<li>最近は sticky bit は directory にセットされる使い方をしている。

<ul>
<li>directory に sticky bit がセットされると、directory 内のファイルは
directory への write 権限を持っていて、かつ

<ul>
<li>ファイルのオーナーである</li>
<li>ディレクトリのオーナーである</li>
<li>スーパーユーザーである
のいずれかを満たすユーザにしか消去や名前の変更ができないようになる。</li>
</ul>
</li>
<li>sticky bit がセットされている directory には、<code>/tmp</code> などがある。

<ul>
<li><code>/tmp</code> には色んなユーザがファイルを作成するので、
パーミッションは 777 になっているが、sticky bit がセットされているので、
ファイルの削除などはオーナーにしかできない。</li>
</ul>
</li>
</ul>
</li>
</ul>


<h2>chown, fchown, and lchown Functions</h2>

<ul>
<li><code>chown()</code> でファイルの user ID や group ID を変更することができる。</li>
</ul>


<p>``` c</p>

<h1>include &lt;unistd.h></h1>

<p>int chown(const char <em>pathname, uid_t owner, gid_t group);
int fchown(int filedes, uid_t owner, gid_t group);
int lchown(const char </em>pathname, uid_t owner, gid_t group);</p>

<p>return 0 if OK, -1 on error
```</p>

<ul>
<li><code>lchown()</code> はシンボリックリンク自体のオーナーを変更する</li>
<li><em>owner</em> または <em>group</em> を -1 にすると、その ID は変更されない</li>
<li><code>_POSIX_CHOWN_RESTRICTED</code> が有効になっていると、他のユーザのファイルの user ID は変更できない。
自分のファイルの group ID は変更できるが、自分が所属しているグループにしか変更できない。</li>
<li>superuser のプロセスからこれらの関数が実行されると、set-user-ID と set-group-ID の bit はクリアされる</li>
</ul>


<h2>File Size</h2>

<ul>
<li><code>stat</code> 構造体の <code>st_size</code> にはファイルのサイズがバイト単位で入っている</li>
<li>このフィールドは regular files, directories, symbolic links のときのみ意味をなす

<ul>
<li>regular file の場合、ファイルサイズ 0 が許容される。これはファイルの最初が end-of-file の場合である。</li>
<li>directory の場合、ファイルサイズは 16 や 512 などの複数の値になる。</li>
<li>symbolic link の場合、ファイルサイズはリンク先のファイル名の長さ (byte) になる。
例えば、リンク先が "usr/lib" のとき、ファイルサイズは 7 になる。</li>
</ul>
</li>
<li>最近の UNIX システムでは、<code>st_blksize</code> と <code>st_blocks</code> というフィールドも用意されている

<ul>
<li><code>st_blksize</code> はファイル I/O の望ましいブロックサイズ</li>
<li><code>st_blocks</code> は割り当てられた 512-byte ブロックの数</li>
<li>standard I/O library では、効率化のため、1回に <code>st_blksize</code> の分だけ read や write を行う</li>
</ul>
</li>
</ul>


<h2>File Truncation</h2>

<p>``` c</p>

<h1>include &lt;unistd.h></h1>

<p>int truncate(const char *pathname, off_t length);
int ftruncate(int filedes, off_t length);</p>

<p>return 0 if OK, -1 on error
```</p>

<ul>
<li>ファイルの長さを <em>length</em> バイトに切り詰める</li>
<li>truncate 前のファイルサイズが <em>length</em> より大きい場合、<em>length</em> より後ろのデータにはアクセスできなくなる</li>
<li>truncate 前のファイルサイズが <em>length</em> より小さい場合、どうなるかは実装依存だが、
XSI-conforming system の場合、ファイルサイズは大きくなる (hole ができる)</li>
</ul>


<h2>File Systems</h2>

<h3>Hard Links</h3>

<ul>
<li>各 i-node は link count を持っている。これは自身の i-node を参照しているディレクトリの数である。</li>
<li>link count が 0 になったときのみ、このファイルは削除することができる。

<ul>
<li>ディレクトリのエントリを削除する関数が delete でなく unlink なのはそのため。</li>
</ul>
</li>
<li>link count は <code>stat</code> 構造体の中の <code>st_nlink</code> メンバに格納されている。この型は <code>nlink_t</code> 型である。</li>
<li>link count の最大値は <code>LINK_MAX</code> で定義されている。</li>
</ul>


<h3>Symbolic Links</h3>

<ul>
<li>symbolic link の指す data block の中にはこのリンクが参照するファイル名が書かれている。</li>
<li>この i-node には file type に <code>S_IFLNK</code> がセットされている。</li>
</ul>


<h3>Directory</h3>

<ul>
<li>directory entry には ファイル名や i-node 番号などが書かれている。</li>
<li>i-node 番号の型は <code>ino_t</code> 型である。</li>
<li>directory entry に書かれた i-node 番号は同じファイルシステム上のものであり、
別のファイルシステムの i-node を参照することはできない。
<code>ln(1)</code> コマンドをファイルシステムをまたがって叩くことができないのはそのためである。</li>
<li><code>mv(1)</code> は directory entry を変更しているだけで、実際のファイルの中身が変更されているわけではない。</li>
<li>leaf directory (他の directory を含んでいない directory) の link count は常に2となる (<code>.</code> と親ディレクトリからの参照)</li>
<li>leaf directory でない directory の link count は 3 以上となる (<code>.</code>, 子ディレクトリの <code>..</code>, 親ディレクトリからの参照)</li>
</ul>


<h2>link, unlink, remove, and rename Functions</h2>

<p>``` c</p>

<h1>include &lt;unistd.h></h1>

<p>int link(cont char <em>existingpath, const char </em>newpath);
int unlink(const char *pathname);</p>

<p>return 0 if OK, -1 on error
```</p>

<ul>
<li><code>link()</code> は <em>existingpath</em> を参照する新しい directory entry を <em>newpath</em> に作成する。

<ul>
<li><em>newpath</em> がすでに存在する場合はエラーとなる。</li>
<li>POSIX.1 はファイルシステムをまたいで link することを許しているが、
ほとんどの実装ではそれぞれのパスは同じファイルシステム上になくてはならない。</li>
<li>directory の hard link を作成できる実装の場合、それができるのは superuser に限られる。

<ul>
<li>loop が発生する恐れがあるため。</li>
<li>多くのファイルシステムの実装では directory の hard link を作ることを許可していない。</li>
</ul>
</li>
</ul>
</li>
<li><p><code>unlink()</code> は directory entry を削除し、 link count を減らす。</p>

<ul>
<li>link count が 0 になったときのみ、このファイルの中身を削除することができるが、
ファイルが open されているときはまだ削除できない。

<ul>
<li>ファイルが close されたときに、kernel がそのファイルを open しているプロセス数をチェックする。
それが 0 なら、次に link count をチェックし、それも 0 ならファイルの中身を削除する。</li>
</ul>
</li>
<li><em>pathname</em> が symbolic link の場合、<code>unlink()</code> は参照先ではなく、symbolic link 自体を削除する。</li>
</ul>
</li>
<li><p>superuser は <code>unlink()</code> に directory を指定することもできるが、それよりも <code>rmdir()</code> を使うべきである。</p></li>
<li>file と directory 両方に使える関数に <code>remove()</code> がある。</li>
</ul>


<p>``` c</p>

<h1>include &lt;stdio.h></h1>

<p>int remove(const char *pathname);</p>

<p>return 0 if OK, -1 on error
```</p>

<ul>
<li><p><code>remove()</code> は対象が file なら <code>unlink()</code> と同じであり、directory なら <code>rmdir()</code> と同じである。</p></li>
<li><p>file や directory は <code>rename()</code> で名前を変えることができる。</p></li>
</ul>


<p>``` c</p>

<h1>include &lt;stdio.h></h1>

<p>int rename(const char <em>oldname, const char </em>newname);</p>

<p>return 0 if OK, -1 on error
```</p>

<ul>
<li><em>newname</em> が既に存在していた場合、<em>newname</em> は削除され、<em>oldname</em> が <em>newname</em> に rename される。

<ul>
<li>directory の場合、<em>newname</em> は空である必要がある。</li>
</ul>
</li>
<li>symbolic link の場合、参照先ではなく、リンク自身が rename される。</li>
<li><em>oldname</em> と <em>newname</em> が同じ場合、変更されずに、0 が返る。</li>
</ul>


<h2>Symbolic Links</h2>

<ul>
<li>symbolic link は i-node を直接参照する hard link とは違い、間接的にファイルを参照する。</li>
<li>symbolic link はファイルシステムをまたぐことに関する制限はない。</li>
<li>directory を指す symbolic link を作る際にも root 権限は必要ない。</li>
<li>ファイル名でファイルを参照する関数には、symbolic link をたどり参照先のファイルを見るものと、
たどらずに、symbolic link 自体を見るものがある。

<ul>
<li><code>chown()</code> がどちらになるかは実装による</li>
<li><code>open()</code> は symbolic link をたどるが、<code>O_CREAT</code> と <code>O_EXCL</code> の両方が付いている場合は例外で、
その時に symbolic link を開こうとすると、エラーとなり、 <code>errno</code> に <code>EEXIST</code> がセットされる。
これは権限のあるプロセスが誤ってファイルに書き込みをしないようにするためである。</li>
</ul>
</li>
</ul>


<h2>symlink and readlink Functions</h2>

<ul>
<li>symbolic link を作成するには <code>symlink()</code> を使う</li>
</ul>


<p>``` c</p>

<h1>include &lt;unistd.h></h1>

<p>int symlink(const char <em>actualpath, const char </em>sympath);</p>

<p>return 0 if OK, -1 on error
```</p>

<ul>
<li><code>open()</code> は symbolic link をたどってしまうため、symbolic link 自身を open したい場合は <code>readlink()</code> を使う</li>
</ul>


<p>``` c</p>

<h1>include &lt;unistd.h></h1>

<p>ssize_t readlink(const char <em>restrict pathname, char </em>restrict buf, size_t bufsize);</p>

<p>return number of bytes read if OK, -1 on error
```
- この関数1つで open, read, close を行なっている。</p>

<h2>File Times</h2>

<p>各ファイルでは3種類の時刻が管理されている
- <code>st_atime</code>: 最後にファイルにアクセスされた時刻。<code>read()</code> など。<code>ls -u</code> でソート
- <code>st_mtime</code>: 最後にファイルの中身が変更された時刻。<code>write()</code> など。<code>ls -t</code> でソート
- <code>st_ctime</code>: 最後に i-node のステータスが変更された時刻。<code>chmod(), chown()</code> など。<code>ls -c</code> でソート</p>

<h2>utime Function</h2>

<p>ファイルの access time や modification time を変更するには <code>utime()</code> を使う</p>

<p>``` c</p>

<h1>include &lt;utime.h></h1>

<p>int utime(const char <em>pathname, const struct utimbuf </em>times);</p>

<p>return 0 if OK, -1 on error
<code>
`utimbuf` 構造体は以下のようになっている
</code> c
struct utimbuf {</p>

<pre><code>time_t actime;  /* access time */
time_t modtime; /* modification time*/
</code></pre>

<p>}
```</p>

<ul>
<li><em>times</em> が null の場合、access time と modification time は現在の時刻に更新される。</li>
<li>chenged-status time を変更する関数は無い。<code>utime()</code> が実行されると自動的に更新される。</li>
</ul>


<h2>mkdir and rmdir Functions</h2>

<ul>
<li><code>mkdir()</code> で空の directory を作成できる。
``` c

<h1>include &lt;sys/stat.h></h1>

<p>int mkdir(const char *pathname, mode_t mode);
return 0 if OK, -1 on error
```</p></li>
<li><code>.</code> と <code>..</code> は自動的に作られる。</li>
<li><em>mode</em> にはプロセスの mask による変更が加えられる。</li>
<li><p>directory の場合、execute bit を付けないと directory 内のファイルにアクセスできなくなるので注意</p></li>
<li><p>空の directory を削除するには <code>rmdir()</code> を使う
``` c</p>

<h1>include &lt;unistd.h></h1>

<p>int rmdir(const char *pathname);</p></li>
</ul>


<p>return 0 if OK, -1 on error
```
- link count が 0 でも、その directory を open しているプロセスがあれば、close されるまで領域は解放されない。
解放はされないが、その directory 内に新しくファイルを置くことはできなくなる。</p>

<h2>Reading Directories</h2>

<p>directory を読むには、以下のような関数を使う
``` c</p>

<h1>include &lt;dirent.h></h1>

<p>DIR <em>opendir(const char </em>pathname);    return pointer if OK, NULL on error
struct dirent <em>readdir(DIR </em>dp);       return pointer if OK, NULL at end of directory or error
void rewinddir(DIR <em>dp);
int closedir(DIR </em>dp);                 return 0 if OK, -1 on error
long telldir(DIR <em>dp);                 return current location in directory associated with dp
void seekdir(DIR </em>dp, long loc);
<code>
`dirent` 構造体 の定義は実装依存だが、少なくとも以下の2つは含まれている
</code> c
struct dirent {</p>

<pre><code>ino_t d_ino;                    /* i-node number */ 
char  d_name[NAME_MAX + 1];     /* null-terminated filename */
</code></pre>

<p>}
```</p>

<ul>
<li><code>DIR</code> は <code>FILE</code> 構造体のようなもので、directory が read されるのを管理するための構造体</li>
<li>directory entries の順番は実装依存だが、たいていアルファベット順にはなっていない</li>
<li><code>rewinddir()</code> は DIR のポインタを先頭に戻す</li>
</ul>


<h2>chdir, fchdir, and getcwd Functions</h2>

<ul>
<li>すべてのプロセスは current working directory を持っている。

<ul>
<li>user がログインすると、current working directory が <code>/etc/passwd</code> の第6フィールドにセットされた home directory に設定される。</li>
</ul>
</li>
<li><p>current working directory はプロセスの attribute である。</p></li>
<li><p><code>chdir()</code> や <code>fchdir()</code> を使うと、それを呼んだプロセスの current working directory が変更できる
``` c</p>

<h1>include &lt;unistd.h></h1>

<p>int chdir(const char *pathname);
int fchdir(int filedes);</p></li>
</ul>


<p>return 0 if OK, -1 on error
```</p>

<ul>
<li>kernel は current working directory の full path を管理しているわけではない</li>
<li>full path を取得するのは、v-node を辿っていけばいいが、そのような関数は既にあり、<code>getcwd()</code> で full path が取得できる
``` c

<h1>include &lt;unistd.h></h1>

<p>char <em>getcwd(char </em>buf, size_t size);</p></li>
</ul>


<p>return buf if OK, NULL on error
```</p>

<h2>Device Special Files</h2>

<p><code>stat</code> 構造体には <code>st_dev</code> と <code>st_rdev</code> の2つのフィールドがある。</p>

<ul>
<li>すべてのファイルシステムには major と minor 2種類のデバイス番号が付けられている。

<ul>
<li>型は <code>dev_t</code> 型</li>
<li>major number はデバイスドライバを識別する番号</li>
<li>minor number はサブデバイスを識別する番号</li>
<li>同じディスクドライブにあるファイルシステムはたいてい同じ major number を持つが、異なる minor number を持つ</li>
</ul>
</li>
<li>major, minor number はそれぞれ <code>major()</code>, <code>minor()</code> マクロで取得できる</li>
<li><code>st_dev</code> はそのファイル名や i-node が格納されているデバイス番号</li>
<li>character special files と block special files の場合のみ <code>st_rdev</code> に値が入っている。
これは実際のデバイスのデバイス番号である。

<ul>
<li><code>/dev/tty0</code> や <code>/dev/hda3</code> などの <code>st_dev</code> のデバイス番号は 0/7 などの <code>devfs</code> 仮想ファイルシステムになっている。
実際のデバイス番号は <code>st_rdev</code> に書かれた 4/0 などである。</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iptables を無効にする]]></title>
    <link href="http://kentaktwo.github.com/blog/2012/10/14/disable-iptables/"/>
    <updated>2012-10-14T00:37:00+09:00</updated>
    <id>http://kentaktwo.github.com/blog/2012/10/14/disable-iptables</id>
    <content type="html"><![CDATA[<p>家でネットワークの勉強するために、VM に Cent OS 入れたのだが、外からアクセスできない。
どうもインストール時には iptables が動いてて、外からのアクセスを拒否してるらしい。</p>

<pre><code>$ sudo /etc/rc.d/init.d/iptables stop
</code></pre>

<p>で iptables を無効にできる。</p>

<p>参考: <a href="http://www.server-world.info/query?os=CentOS_6&amp;p=initial_conf&amp;f=2">http://www.server-world.info/query?os=CentOS_6&amp;p=initial_conf&amp;f=2</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Unix Network Programming Chapter 3]]></title>
    <link href="http://kentaktwo.github.com/blog/2012/07/02/unp-chapter-3/"/>
    <updated>2012-07-02T22:04:00+09:00</updated>
    <id>http://kentaktwo.github.com/blog/2012/07/02/unp-chapter-3</id>
    <content type="html"><![CDATA[<h1>Sockets Introduction</h1>

<!--more-->


<h2>Socket Address Structures</h2>

<p>ほとんどのソケット関数は引数にソケットアドレス構造体のポインタを必要とする。</p>

<h3>IPv4 Socket Address Structure</h3>

<p>``` c</p>

<h1>include &lt;netinet/in.h></h1>

<p>struct in_addr {</p>

<pre><code>in_addr_t       s_addr;         /* 32-bit IPv4 address */
</code></pre>

<p>};</p>

<p>struct sockaddr_in {</p>

<pre><code>uint8_t         sin_len;        /* length of structure (16) */
sa_family_t     sin_family;     /* AF_INET */
in_port_t       sin_port;       /* 16-bit TCP or UDP port number */
struct in_addr  sin_addr;       /* 32-bit IPv4 address */
char            sin_zero[8];    /* unused */
</code></pre>

<p>};
<code>``
-</code>sin_zero<code>はソケットアドレス構造体のサイズを少なくとも 16 bytes にするため
- IP アドレスとポート番号は常にネットワークバイトオーダー
-</code>sin_addr` が構造体になっているのは歴史的な理由から。昔は union でクラス A, B, C のアドレスを処理していたらしい。</p>

<h3>Generic Socket Address Structure</h3>

<p>``` c</p>

<h1>include &lt;sys/socket.h></h1>

<p>struct sockaddr {</p>

<pre><code>uint8_t     sa_len;
sa_family_t sa_family;      /* address family: AF_xxx value */
char        sa_data[14];    /* protocol-specific address */
</code></pre>

<p>};
<code>
- ソケット関数に渡すときは、`sockaddr` にキャストして渡す
</code> c
struct sockaddr_in serv;  /<em> IPv4 </em>/</p>

<p>/<em> fill in serv{} </em>/</p>

<p>bind(sockfd, (struct sockaddr *)&amp;serv, sizeof(serv));
```</p>

<h3>IPv6 Socket Address Structure</h3>

<p>``` c</p>

<h1>include &lt;netinet/in.h></h1>

<p>struct in6_addr {</p>

<pre><code>uint8_t         s6_addr[16];        /* 128-bit IPv6 address */
</code></pre>

<p>};</p>

<h1>define SIN6_LEN  /<em> required for compile-time tests </em>/</h1>

<p>struct sockaddr_in6 {</p>

<pre><code>uint8_t         sin6_len;           /* length of this struct (28) */
sa_family_t     sin6_family;        /* AF_INET6 */
in_port_t       sin6_port;          /* transport layer port# */
uint32_t        sin6_flowinfo;      /* flow information, undefined */
struct in6_addr sin6_addr;          /* IPv6 address */
uint32_t        sin6_scope_id;      /* set of interfaces for a scope */
</code></pre>

<p>};
<code>``
- システムがソケットアドレス構造体の長さをサポートする場合、</code>SIN6_LEN` を定義しなくてはならない
- アドレスとポート番号はネットワークバイトオーダー</p>

<h3>New Generic Socket Address Structure</h3>

<p>``` c</p>

<h1>include &lt;netinet/in.h></h1>

<p>struct sockaddr_storage {</p>

<pre><code>uint8_t     ss_len;     /* length of this struct (implementation dependent) */
sa_family_t ss_family;  /* address family: AF_xxx value */
/* implementation-dependent elements to provide */
</code></pre>

<p>};
```
- IPv6 をサポートするためにできた generic socket
- システムがサポートするソケットアドレス構造体をカバーできるよう十分大きいサイズが取られる</p>

<h2>Value-Result Arguments</h2>

<p>ソケット関数では引数にソケットアドレス構造体とそのサイズを渡すが、
<code>accept</code>, <code>recvfrom</code>, <code>getsockname</code>, <code>getpeername</code> などのプロセスがカーネルから
ソケットアドレス構造体を受け取る関数では、引数に入れたサイズが関数実行後に変わることがある
(<code>sockaddr_un</code> など)。</p>

<h2>Byte Ordering Functions</h2>

<ul>
<li>バイトをデータに格納する順序には2種類ある

<ul>
<li>リトルエンディアン: 下位バイトが先のアドレスにくる</li>
<li>ビッグエンディアン: 上位バイトが先のアドレスにくる</li>
</ul>
</li>
<li>システムによってバイトオーダーが異なるので、ネットワークで扱うバイトオーダーを決める必要がある

<ul>
<li>ネットワークバイトオーダーはビッグエンディアン</li>
</ul>
</li>
<li>ホストバイトオーダーとネットワークバイトオーダーを変換する関数が用意されている
``` c

<h1>include &lt;netinet/in.h></h1>

<p>uint16_t htons(uint16_t host16bitvalue);
uint32_t htonl(uint32_t host32bitvalue);</p></li>
</ul>


<p>uint16_t ntohs(uint16_t net16bitvalue);
uint32_t ntohl(uint32_t net32bitvalue);
```</p>

<h2>Byte Manipulation Functions</h2>

<ul>
<li>バイト列を操作する関数は2つのグループに分かれる

<ul>
<li><code>b</code> で始まる関数 (4.2BSD)</li>
<li><code>mem</code> で始まる関数 (ANSI C)
``` c

<h1>include &lt;strings.h></h1>

void bzero(void <em>dest, size_t nbytes);
void bcopy(const void </em>src, void <em>dest, size_t nbytes);
int bcmp(const void </em>ptr1, const void *ptr2, size_t nbytes);
<code>
</code> c

<h1>include &lt;string.h></h1>

<p>void <em>memset(void </em>dest, int c, size_t len);
void <em>memcpy(void </em>dest, const void <em>src, size_t nbytes);
int memcmp(const void </em>ptr1, const void *ptr2, size_t nbytes);
```</p></li>
</ul>
</li>
<li><code>bzero</code> は 0 にセットするが、<code>memset</code> は特定の値にセットできる</li>
<li><code>bcopy</code> と <code>memcpy</code> ではコピー元とコピー先のアドレスを引数に入れる順序が逆</li>
<li><code>bcopy</code> は領域が重なっていても動作するが、<code>memcpy</code> はダメ

<ul>
<li>重なっている場合は <code>memmove</code> を使う</li>
<li><code>bcopy</code> は廃止予定</li>
</ul>
</li>
<li><code>bcmp</code> も <code>memcmp</code> も2つのバイト列が異なっていれば nonzero を返すが、
<code>memcmp</code> の場合、最初に異なったバイトが <em>ptr1</em> > <em>ptr2</em> のとき正、
<em>ptr1</em> &lt; <em>ptr2</em> のとき負の値が返る</li>
</ul>


<h2><code>inet_pton</code> and <code>inet_ntop</code> Functions</h2>

<ul>
<li>IP アドレスの文字列表記と数値の変換を行うには <code>inet_pton</code> と <code>inet_ntop</code> を使う。</li>
<li><code>inet_aton</code>, <code>inet_addr</code>, <code>inet_ntoa</code> は IPv4 のみでしか使えない

<ul>
<li>さらに、<code>inet_addr</code> は戻り値がアドレスを表す数値 (32-bit, ネットワークバイトオーダー) だが、
エラー時に返す値 <code>INADDR_NONE</code> が 2<sup>32</sup> - 1 のため、255.255.255.255 が変換できない
``` c

<h1>include &lt;arpa/inet.h></h1>

<p>int inet_pton(int family, const char <em>strptr, void </em>addrptr);  // 文字列から数値
const char <em>inet_ntop(int family, const void </em>addrptr, char *strptr, size_t len);  // 数値から文字列
```</p></li>
</ul>
</li>
<li>数値はネットワークバイトオーダー</li>
<li><em>family</em> には <code>AF_INET</code> または <code>AF_INET6</code> を入れる</li>
<li><em>len</em> には変換後の文字列を入れるバッファ <em>strptr</em> の長さを入れる。
<code>&lt;netinet/in.h&gt;</code> に <code>INET_ADDRSTRLEN</code> と <code>INET6_ADDRSTRLEN</code> が定義されている。</li>
<li><em>strptr</em> に null は入れられない。メモリを確保してそのサイズを指定する必要がある。</li>
<li><code>inet_pton()</code> に成功すると 1, 失敗すると 0 が返ってくる</li>
<li><code>inet_ntop()</code> に成功すると、戻り値として <em>strptr</em> が返る</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Advanced Programming in the UNIX enviroment Chapter 3]]></title>
    <link href="http://kentaktwo.github.com/blog/2012/06/30/apue-chapter-3/"/>
    <updated>2012-06-30T13:49:00+09:00</updated>
    <id>http://kentaktwo.github.com/blog/2012/06/30/apue-chapter-3</id>
    <content type="html"><![CDATA[<h1>File I/O</h1>

<!--more-->


<h2>File Descriptors</h2>

<ul>
<li>標準入出力は <code>&lt;unistd.h&gt;</code> に定義されている

<ul>
<li><code>STDIN_FILENO</code>: 0</li>
<li><code>STDOUT_FILENO</code>: 1</li>
<li><code>STDERR_FILENO</code>: 2</li>
<li>0, 1, 2 に割り当てられているのは慣習であり、UNIX の取り決めではない</li>
</ul>
</li>
<li>File descriptor の範囲は 0 から <code>OPEN_MAX</code> まで

<ul>
<li>昔は 19 までだったが最近は 63 まであるシステムが多い</li>
</ul>
</li>
</ul>


<h2>open Function</h2>

<p>``` c</p>

<h1>include &lt;fcntl.h></h1>

<p>int open(const char <em>pathname, int oflag, ... /</em> mode_t mode */ );
<code>``
- ファイルを開いたり作成したりする
- 第二引数 (_oflag_) に入れるオプションは</code>&lt;fcntl.h>` に定義されている</p>

<pre><code>- `O_RDONLY`, `O_WRONLY`, `O_RDWR` のいずれかは必須
</code></pre>

<ul>
<li>open される file descriptor は使われていないもののうち最小のものになる

<ul>
<li>なので、標準出力(1) を close して open すると 1番に割り当てられたりする</li>
</ul>
</li>
<li>ファイル名が長すぎた (<code>NAME_MAX</code>以上) ときどうするかは OS 依存

<ul>
<li>System V 系だと勝手にはみ出た分を切り捨てる</li>
<li>BSD 系だとエラー (<code>ENAMETOOLONG</code>) を出す</li>
<li>POSIX.1 なら <code>_POSIX_NO_TRUNC</code> を定義すればエラーを出すようにできる</li>
</ul>
</li>
</ul>


<h2>creat Function</h2>

<p>``` c</p>

<h1>include &lt;fcntl.h></h1>

<p>int creat(const char *pathname, mode_t mode);
<code>``
-</code>open(pathname, O_WRONLY | O_CREAT | O_TRUNC, mode);` と同じ</p>

<h2>close Function</h2>

<p>``` c</p>

<h1>include &lt;unistd.h></h1>

<p>int close(int filedes);
```
- プロセスが終了するときにはカーネルによって自動的に close される</p>

<h2>lseek Function</h2>

<p>``` c</p>

<h1>include &lt;unistd.h></h1>

<p>off_t lseek(int filedes, off_t offset, int whence);
<code>``
- オフセットの位置を指定する
- open されたファイルは現在のファイルの始めからのオフセットを非負整数で持っている
- デフォルトでは open されたときオフセットは 0 に設定される (</code>O_APPEND` を設定している場合を除く)
- <em>offset</em> の値の適用の仕方は <em>whence</em> の値による</p>

<pre><code>- `SEEK_SET`: ファイルの始めから _offset_ 進めたところ
- `SEEK_CUR`: 現在のオフセットから _offset_ 進めたところ
- `SEEK_END`: ファイルの終わり（正確には現在のファイルサイズ）から _offset_ 進めたところ
</code></pre>

<ul>
<li><code>lseek</code> は新しいファイルオフセットを返すので、これを利用して現在のオフセットを取得することができる
<code>c
off_t currpos = lseek(fd, 0, SEEK_CUR);
</code></li>
<li>ファイルオフセットをファイルサイズより大きくして write すると、その間は 0 で埋められるが、ディスクブロックは割り当てられない</li>
</ul>


<h2>od command</h2>

<ul>
<li>ファイルコンテンツを見る</li>
<li><code>-c</code> オプションをつけるとコンテンツを文字として表示する</li>
</ul>


<h2>read Function</h2>

<p>``` c</p>

<h1>include &lt;unistd.h></h1>

<p>ssize_t read(int filedes, void *buf, size_t nbytes);
```
- 戻り値は実際に読み込んだバイト数</p>

<pre><code>- EOF のときは 0
</code></pre>

<h2>write Function</h2>

<p>``` c</p>

<h1>include &lt;unistd.h></h1>

<p>ssize_t write(int filedes, const void *buf, size_t nbytes);
```
- ディスクがいっぱいで書き込めなくなったときはエラー (-1) を返す</p>

<h2>File Sharing</h2>

<ul>
<li>カーネルは open されたファイルを3種類のデータ構造で管理している

<ul>
<li>process table

<ul>
<li>各プロセスが持つ</li>
<li>open された file descriptor のテーブル</li>
<li>各 descriptor は file table へのポインタを持つ</li>
</ul>
</li>
<li>file table

<ul>
<li>ファイルステータス (read, write, append, sync など)、現在のファイルオフセットを持つ</li>
<li>v-node table へのポインタを持つ</li>
</ul>
</li>
<li>v-node table

<ul>
<li>ファイルタイプ、i-node 情報を持つ</li>
<li>i-node はファイルのオーナー、サイズ、実データの格納場所へのポインタなどを持っている</li>
</ul>
</li>
</ul>
</li>
<li>Linux には v-node は無いが、その代わりに generic i-node が使われる</li>
<li>2つのプロセスが同じファイルを open すると、file table は2つできるが、それらが同じ v-node table を指す</li>
</ul>


<h2>Atomic Operations</h2>

<p>``` c</p>

<h1>include &lt;unistd.h></h1>

<p>ssize_t pread(int filedes, void <em>buf, size_t nbytes, off_t offset);
ssize_t pwrite(int filedes, const void </em>buf, size_t nbytes, off_t offset);
<code>``
</code>lseek<code>と</code>read<code>または</code>write` を atomic に行なってくれる</p>

<h2>dup and dup2 Functions</h2>

<p>``` c</p>

<h1>include &lt;unistd.h></h1>

<p>int dup(int filedes);
int dup2(int filedes, int filedes2);
```
- file descriptor を複製する</p>

<pre><code>- dup では複製されたディスクリプタは使用可能なディスクリプタのうち最小のものとなる
- dup2 では複製されたディスクリプタの番号を _filedes2_ で指定する
</code></pre>

<ul>
<li>元のディスクリプタと複製されたディスクリプタは同じ file table を指す

<ul>
<li>なので、ファイルステータスやファイルオフセットなどが共有される</li>
</ul>
</li>
</ul>


<h2>sync, fsync, and fdatasync Functions</h2>

<p>``` c</p>

<h1>include &lt;unistd.h></h1>

<p>int fsync(int filedes);
int fdatasync(int filedes);
int sync(void);
<code>``
- UNIX の実装では、write されたデータはカーネルによって一旦バッファにコピーされ、少し後にディスクに書き込まれる
-</code>sync` を呼ぶと、すべての変更されたブロックを書き込む</p>

<pre><code>- 通常デーモンによって30秒に1回 `sync` が呼ばれている
- ディスクの書き込みが終わるのを待たずに return する
</code></pre>

<ul>
<li><code>fsync</code> は特定のファイルディスクリプタに対して行う

<ul>
<li>ディスクへの書き込みが終わるのを待つ</li>
</ul>
</li>
<li><code>fdatasync</code> はデータの更新のみを行う

<ul>
<li><code>fsync</code> はファイル属性の更新も行う</li>
</ul>
</li>
</ul>


<h2>fcntl Function</h2>

<p>``` c</p>

<h1>include &lt;fcntl.h></h1>

<p>int fcntl(int filedes, int cmd, ... /<em> int arg </em>/ );
```
- open されたファイルのプロパティを変更する
- 以下のようなことができる (<em>cmd</em> で指定)</p>

<pre><code>- descriptor の複製
- descriptor flag の取得・設定
- file status flag の取得・設定
- オーナーシップ (process ID, group ID) の取得・設定
- record lock の取得・設定（詳しくは14章）
</code></pre>

<h2>/dev/fd</h2>

<ul>
<li><code>/dev/fd</code> に 0, 1, 2 と呼ばれるファイルがあり、それぞれ file descriptor 0, 1, 2 に対応している</li>
<li><code>/dev/fd/n</code> を open する際、<em>mode</em> の値は無視される。 <code>/dev/fd/0</code> は read only であり、
<code>c
  fd = open("/dev/fd/0", O_RDWR);
</code>
としても fd に書き込むことはできない</li>
<li>shell で使われることが多い
<code>sh
filter file2 | cat file1 - file3 | lpr
</code>
は file1, filter file2, file3 を cat しているが (<code>-</code> は標準入力)、
<code>-</code> は場合によって標準入力だったり出力だったりわかりにくいので、
<code>sh
filter file2 | cat file1 /dev/fd/0 file3 | lpr
</code>
として明確に書くことができる。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Unix Network Programming Chapter 2]]></title>
    <link href="http://kentaktwo.github.com/blog/2012/05/07/unp-chapter-2/"/>
    <updated>2012-05-07T23:41:00+09:00</updated>
    <id>http://kentaktwo.github.com/blog/2012/05/07/unp-chapter-2</id>
    <content type="html"><![CDATA[<h1>The Transport Layer: TCP, UDP, and SCTP</h1>

<!--more-->


<h2>User Datagram Protocol (UDP)</h2>

<ul>
<li>シンプルなプロトコル

<ol>
<li>アプリケーションがメッセージを UDP socket に書く</li>
<li>UDP socket は UDP datagram にカプセル化される</li>
<li>UDP datagram は IP datagram にカプセル化される</li>
<li>IP datagram が目的地に送信される</li>
</ol>
</li>
<li>UDP datagram が目的地に届けられる補償は無い</li>
<li>UDP datagram は長さを持つ

<ul>
<li>datagram の長さの情報はデータと一緒に受信者に届けられる</li>
</ul>
</li>
<li>UDP は <em>connectionless</em> service とも言われる

<ul>
<li>client - server 間に長期間の依存を持たないため</li>
<li>例えば UDP client が socket を作って datagram を server に送り、その後すぐに別の datagram を別の servevr に同じ socket で送ることが可能</li>
</ul>
</li>
</ul>


<h2>Transmission Control Protocol (TCP)</h2>

<ul>
<li>クライアント・サーバ間でコネクションを張る</li>
<li>信頼性 <em>(reliability)</em> がある

<ul>
<li>TCP がデータを送信すると、応答 (acknowledgment) が来るのを待つ</li>
<li>応答が来ない場合、TCP は自動的にデータを再送信し、さらに待つ</li>
<li>しばらく繰り返しても来ない場合は諦める</li>
</ul>
</li>
<li>RTT <em>(round trip time)</em> を推測するアルゴリズムを含んでいる

<ul>
<li>応答にどれだけ時間がかかりそうかを推測する</li>
</ul>
</li>
<li>TCP が送信するデータには各 byte に連番 <em>(sequence numbers)</em> が振られている

<ul>
<li>到着したセグメント（TCP が IP に渡すデータの単位）が壊れていた場合、セグメントを再要求する</li>
<li>データが重複していた場合、番号を見て重複しているデータを削除する</li>
</ul>
</li>
<li><em>flow control</em> を提供する

<ul>
<li>peer に対して何バイトのサイズのデータを受け入れられるか <em>(advertised window)</em> 伝える</li>
<li>送信者が受信バッファを超えるデータを送ることを防ぐ</li>
<li>送信者からデータを受信すると window サイズは小さくなり、受信アプリケーションがバッファからデータを読むと window サイズは大きくなる</li>
</ul>
</li>
<li>TCP コネクションは <em>full-duplex</em> である

<ul>
<li>アプリケーションはいつでもデータの送信と受信ができる</li>
<li>sequence number や window size の状態の経過を追い続ける</li>
</ul>
</li>
</ul>


<h2>Stream Control Transmission Protocol (SCTP)</h2>

<ul>
<li>クライアント・サーバ間の接続は connection ではなく、 <em>association</em> と呼ばれる

<ul>
<li>2システム間の通信が2つ以上のアドレスを使用することができる</li>
</ul>
</li>
<li><em>message-oriented</em> である

<ul>
<li>TCP は byte 指向</li>
</ul>
</li>
<li>接続間で複数のストリーム (multiple stream) を提供する

<ul>
<li>ストリームの1つに含まれる message が失われても、他のストリームの message の配信に影響しない</li>
</ul>
</li>
<li>マルチホーミング (multihoming) を提供する

<ul>
<li>1つの SCTP エンドポイントが複数の IP アドレスをサポートする</li>
<li>ネットワークの不安定さに対するロバスト性を向上させる</li>
</ul>
</li>
</ul>


<h2>Three-Way Handshake</h2>

<p>TCP connection を張るときには以下のような処理が行われる：</p>

<ol>
<li>サーバは <code>socket</code>, <code>bind</code>, <code>listen</code> を呼び、接続を受け入れる準備をする <em>(passive open)</em></li>
<li>クライアントは <code>connect</code> を呼び <em>active open</em> を発行する。
クライアント TCP は SYN (synchronize) segment を送信して、サーバにクライアントが送る予定のデータサイズを教える。</li>
<li>サーバはクライアントの SYN を受け入れ、ACK (acknowledge) と自分の SYN を送る。
SYN にはサーバが送る予定のデータサイズが含まれている。
サーバの SYN とクライアントの SYN に対する ACK は1つのセグメントで送られる。</li>
<li>クライアントはサーバの SYN を受け入れる (ACK)</li>
</ol>


<h2>TCP Connection Termination</h2>

<p>接続を切るときは以下のような処理で行われる：</p>

<ol>
<li>片方のアプリケーションが <code>close</code> を呼び <em>(active close)</em>、TCP は FIN segment を送る。</li>
<li>もう片方の TCP が FIN を受け入れる <em>(passive close)</em>。FIN は end-of-file としてアプリケーションに通知される。</li>
<li>しばらくして、end-of-file を受信したアプリケーションはソケットを <code>close</code> し、FIN を送る。</li>
<li>active close を行った側の TCP が FIN を受け入れる。</li>
</ol>


<p>2 から 3 の間で passive close を行った側から active close を行った側にデータが送られることがある <em>(half-close)</em>。</p>

<h2>TIME_WAIT State</h2>

<ul>
<li>active close を行った側が close を受け取ったあとのタイムアウト待ち状態

<ul>
<li>タイムアウト時間は MSL <em>(maximum segment lifetime)</em> の2倍 (2MSL)</li>
</ul>
</li>
<li>TCP のコネクションを確実に切断する

<ul>
<li>ルータの異常によりループが発生すると古いパケットが残り続ける</li>
<li>そこで TCP がパケットを再送すると、ループが解消されたときに重複してパケットが送られる</li>
</ul>
</li>
<li>古い重複したセグメントをネットワークから expire させる

<ul>
<li>コネクションを再接続するときに、古いパケットが残らないようにする</li>
</ul>
</li>
</ul>


<h2>Four-Way Handshake</h2>

<p>SCTP connection を張るときには以下のような処理が行われる：</p>

<ol>
<li>サーバは <code>socket</code>, <code>bind</code>, <code>listen</code> を呼び、passive open を行う</li>
<li>クライアントは <code>connect</code> を呼び、active open を行う。
これによりクライアントは IP のリスト、初期シーケンス番号、この association での全てのパケットを識別するためのタグ、
クライアントがリクエストするストリーム量、クライアントが受け入れることのできるストリーム量を含んだ INIT メッセージを送る。</li>
<li>サーバはクライアントの INIT を受け取り、 INIT-ACK メッセージを送る。
INIT-ACK には 2. で述べた INIT が持つ情報に加えて state cookie が含まれる。
state cookie にはサーバが association が正当であることを補償するための全ての状態が含まれている。</li>
<li>クライアントはサーバの state cookie を COOKIE-ECHO メッセージとして返す。</li>
<li>サーバは cookie が正しいことを確かめ、COOKIE-ACK メッセージを送り association を成立させる。</li>
</ol>


<p>four-way handshake は SCTP が DoS 攻撃を防ぐために用いられる。</p>

<h2>Association Terminate</h2>

<ul>
<li>SCTP では TCP とは違い half-closed は受け入れられず、片方が association を切断した時にはもう片方はデータの送信をやめなければならない。</li>
<li>SCTP では verification tags があるため、TIME_WAIT state は存在しない。</li>
</ul>


<h2>Port Numbers</h2>

<ul>
<li>UDP, SCTP, TCP はプロセスを区別するために 16-bit integer のポート番号を使用する。</li>
<li>ポート番号は以下の3つのレンジに分かれる

<ul>
<li><em>well-known ports</em>: 0 - 1023<br/>
IANA によって管理されているポート</li>
<li><em>registered ports</em>: 1024 - 49151<br/>
IANA によって管理はされていないが、使い方を決めているポート</li>
<li><em>dynamic (private) ports</em>: 49152 - 65535<br/>
IANA が管理していないポート。 <em>ephemeral ports</em> （transport protocol によってクライアントに割り当てられるポート）に使われる。</li>
</ul>
</li>
<li>接続先を決めるための2つの値である IP アドレスとポート番号の組は <em>socket</em> と呼ばれる</li>
</ul>

]]></content>
  </entry>
  
</feed>
