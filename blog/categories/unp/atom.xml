<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: unp | ApprEngineer.log]]></title>
  <link href="http://kentaktwo.github.com/blog/categories/unp/atom.xml" rel="self"/>
  <link href="http://kentaktwo.github.com/"/>
  <updated>2012-10-14T00:42:33+09:00</updated>
  <id>http://kentaktwo.github.com/</id>
  <author>
    <name><![CDATA[kentaktwo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Unix Network Programming Chapter 3]]></title>
    <link href="http://kentaktwo.github.com/blog/2012/07/02/unp-chapter-3/"/>
    <updated>2012-07-02T22:04:00+09:00</updated>
    <id>http://kentaktwo.github.com/blog/2012/07/02/unp-chapter-3</id>
    <content type="html"><![CDATA[<h1>Sockets Introduction</h1>

<!--more-->


<h2>Socket Address Structures</h2>

<p>ほとんどのソケット関数は引数にソケットアドレス構造体のポインタを必要とする。</p>

<h3>IPv4 Socket Address Structure</h3>

<p>``` c</p>

<h1>include &lt;netinet/in.h></h1>

<p>struct in_addr {</p>

<pre><code>in_addr_t       s_addr;         /* 32-bit IPv4 address */
</code></pre>

<p>};</p>

<p>struct sockaddr_in {</p>

<pre><code>uint8_t         sin_len;        /* length of structure (16) */
sa_family_t     sin_family;     /* AF_INET */
in_port_t       sin_port;       /* 16-bit TCP or UDP port number */
struct in_addr  sin_addr;       /* 32-bit IPv4 address */
char            sin_zero[8];    /* unused */
</code></pre>

<p>};
<code>``
-</code>sin_zero<code>はソケットアドレス構造体のサイズを少なくとも 16 bytes にするため
- IP アドレスとポート番号は常にネットワークバイトオーダー
-</code>sin_addr` が構造体になっているのは歴史的な理由から。昔は union でクラス A, B, C のアドレスを処理していたらしい。</p>

<h3>Generic Socket Address Structure</h3>

<p>``` c</p>

<h1>include &lt;sys/socket.h></h1>

<p>struct sockaddr {</p>

<pre><code>uint8_t     sa_len;
sa_family_t sa_family;      /* address family: AF_xxx value */
char        sa_data[14];    /* protocol-specific address */
</code></pre>

<p>};
<code>
- ソケット関数に渡すときは、`sockaddr` にキャストして渡す
</code> c
struct sockaddr_in serv;  /<em> IPv4 </em>/</p>

<p>/<em> fill in serv{} </em>/</p>

<p>bind(sockfd, (struct sockaddr *)&amp;serv, sizeof(serv));
```</p>

<h3>IPv6 Socket Address Structure</h3>

<p>``` c</p>

<h1>include &lt;netinet/in.h></h1>

<p>struct in6_addr {</p>

<pre><code>uint8_t         s6_addr[16];        /* 128-bit IPv6 address */
</code></pre>

<p>};</p>

<h1>define SIN6_LEN  /<em> required for compile-time tests </em>/</h1>

<p>struct sockaddr_in6 {</p>

<pre><code>uint8_t         sin6_len;           /* length of this struct (28) */
sa_family_t     sin6_family;        /* AF_INET6 */
in_port_t       sin6_port;          /* transport layer port# */
uint32_t        sin6_flowinfo;      /* flow information, undefined */
struct in6_addr sin6_addr;          /* IPv6 address */
uint32_t        sin6_scope_id;      /* set of interfaces for a scope */
</code></pre>

<p>};
<code>``
- システムがソケットアドレス構造体の長さをサポートする場合、</code>SIN6_LEN` を定義しなくてはならない
- アドレスとポート番号はネットワークバイトオーダー</p>

<h3>New Generic Socket Address Structure</h3>

<p>``` c</p>

<h1>include &lt;netinet/in.h></h1>

<p>struct sockaddr_storage {</p>

<pre><code>uint8_t     ss_len;     /* length of this struct (implementation dependent) */
sa_family_t ss_family;  /* address family: AF_xxx value */
/* implementation-dependent elements to provide */
</code></pre>

<p>};
```
- IPv6 をサポートするためにできた generic socket
- システムがサポートするソケットアドレス構造体をカバーできるよう十分大きいサイズが取られる</p>

<h2>Value-Result Arguments</h2>

<p>ソケット関数では引数にソケットアドレス構造体とそのサイズを渡すが、
<code>accept</code>, <code>recvfrom</code>, <code>getsockname</code>, <code>getpeername</code> などのプロセスがカーネルから
ソケットアドレス構造体を受け取る関数では、引数に入れたサイズが関数実行後に変わることがある
(<code>sockaddr_un</code> など)。</p>

<h2>Byte Ordering Functions</h2>

<ul>
<li>バイトをデータに格納する順序には2種類ある

<ul>
<li>リトルエンディアン: 下位バイトが先のアドレスにくる</li>
<li>ビッグエンディアン: 上位バイトが先のアドレスにくる</li>
</ul>
</li>
<li>システムによってバイトオーダーが異なるので、ネットワークで扱うバイトオーダーを決める必要がある

<ul>
<li>ネットワークバイトオーダーはビッグエンディアン</li>
</ul>
</li>
<li>ホストバイトオーダーとネットワークバイトオーダーを変換する関数が用意されている
``` c

<h1>include &lt;netinet/in.h></h1>

<p>uint16_t htons(uint16_t host16bitvalue);
uint32_t htonl(uint32_t host32bitvalue);</p></li>
</ul>


<p>uint16_t ntohs(uint16_t net16bitvalue);
uint32_t ntohl(uint32_t net32bitvalue);
```</p>

<h2>Byte Manipulation Functions</h2>

<ul>
<li>バイト列を操作する関数は2つのグループに分かれる

<ul>
<li><code>b</code> で始まる関数 (4.2BSD)</li>
<li><code>mem</code> で始まる関数 (ANSI C)
``` c

<h1>include &lt;strings.h></h1>

void bzero(void <em>dest, size_t nbytes);
void bcopy(const void </em>src, void <em>dest, size_t nbytes);
int bcmp(const void </em>ptr1, const void *ptr2, size_t nbytes);
<code>
</code> c

<h1>include &lt;string.h></h1>

<p>void <em>memset(void </em>dest, int c, size_t len);
void <em>memcpy(void </em>dest, const void <em>src, size_t nbytes);
int memcmp(const void </em>ptr1, const void *ptr2, size_t nbytes);
```</p></li>
</ul>
</li>
<li><code>bzero</code> は 0 にセットするが、<code>memset</code> は特定の値にセットできる</li>
<li><code>bcopy</code> と <code>memcpy</code> ではコピー元とコピー先のアドレスを引数に入れる順序が逆</li>
<li><code>bcopy</code> は領域が重なっていても動作するが、<code>memcpy</code> はダメ

<ul>
<li>重なっている場合は <code>memmove</code> を使う</li>
<li><code>bcopy</code> は廃止予定</li>
</ul>
</li>
<li><code>bcmp</code> も <code>memcmp</code> も2つのバイト列が異なっていれば nonzero を返すが、
<code>memcmp</code> の場合、最初に異なったバイトが <em>ptr1</em> > <em>ptr2</em> のとき正、
<em>ptr1</em> &lt; <em>ptr2</em> のとき負の値が返る</li>
</ul>


<h2><code>inet_pton</code> and <code>inet_ntop</code> Functions</h2>

<ul>
<li>IP アドレスの文字列表記と数値の変換を行うには <code>inet_pton</code> と <code>inet_ntop</code> を使う。</li>
<li><code>inet_aton</code>, <code>inet_addr</code>, <code>inet_ntoa</code> は IPv4 のみでしか使えない

<ul>
<li>さらに、<code>inet_addr</code> は戻り値がアドレスを表す数値 (32-bit, ネットワークバイトオーダー) だが、
エラー時に返す値 <code>INADDR_NONE</code> が 2<sup>32</sup> - 1 のため、255.255.255.255 が変換できない
``` c

<h1>include &lt;arpa/inet.h></h1>

<p>int inet_pton(int family, const char <em>strptr, void </em>addrptr);  // 文字列から数値
const char <em>inet_ntop(int family, const void </em>addrptr, char *strptr, size_t len);  // 数値から文字列
```</p></li>
</ul>
</li>
<li>数値はネットワークバイトオーダー</li>
<li><em>family</em> には <code>AF_INET</code> または <code>AF_INET6</code> を入れる</li>
<li><em>len</em> には変換後の文字列を入れるバッファ <em>strptr</em> の長さを入れる。
<code>&lt;netinet/in.h&gt;</code> に <code>INET_ADDRSTRLEN</code> と <code>INET6_ADDRSTRLEN</code> が定義されている。</li>
<li><em>strptr</em> に null は入れられない。メモリを確保してそのサイズを指定する必要がある。</li>
<li><code>inet_pton()</code> に成功すると 1, 失敗すると 0 が返ってくる</li>
<li><code>inet_ntop()</code> に成功すると、戻り値として <em>strptr</em> が返る</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Unix Network Programming Chapter 2]]></title>
    <link href="http://kentaktwo.github.com/blog/2012/05/07/unp-chapter-2/"/>
    <updated>2012-05-07T23:41:00+09:00</updated>
    <id>http://kentaktwo.github.com/blog/2012/05/07/unp-chapter-2</id>
    <content type="html"><![CDATA[<h1>The Transport Layer: TCP, UDP, and SCTP</h1>

<!--more-->


<h2>User Datagram Protocol (UDP)</h2>

<ul>
<li>シンプルなプロトコル

<ol>
<li>アプリケーションがメッセージを UDP socket に書く</li>
<li>UDP socket は UDP datagram にカプセル化される</li>
<li>UDP datagram は IP datagram にカプセル化される</li>
<li>IP datagram が目的地に送信される</li>
</ol>
</li>
<li>UDP datagram が目的地に届けられる補償は無い</li>
<li>UDP datagram は長さを持つ

<ul>
<li>datagram の長さの情報はデータと一緒に受信者に届けられる</li>
</ul>
</li>
<li>UDP は <em>connectionless</em> service とも言われる

<ul>
<li>client - server 間に長期間の依存を持たないため</li>
<li>例えば UDP client が socket を作って datagram を server に送り、その後すぐに別の datagram を別の servevr に同じ socket で送ることが可能</li>
</ul>
</li>
</ul>


<h2>Transmission Control Protocol (TCP)</h2>

<ul>
<li>クライアント・サーバ間でコネクションを張る</li>
<li>信頼性 <em>(reliability)</em> がある

<ul>
<li>TCP がデータを送信すると、応答 (acknowledgment) が来るのを待つ</li>
<li>応答が来ない場合、TCP は自動的にデータを再送信し、さらに待つ</li>
<li>しばらく繰り返しても来ない場合は諦める</li>
</ul>
</li>
<li>RTT <em>(round trip time)</em> を推測するアルゴリズムを含んでいる

<ul>
<li>応答にどれだけ時間がかかりそうかを推測する</li>
</ul>
</li>
<li>TCP が送信するデータには各 byte に連番 <em>(sequence numbers)</em> が振られている

<ul>
<li>到着したセグメント（TCP が IP に渡すデータの単位）が壊れていた場合、セグメントを再要求する</li>
<li>データが重複していた場合、番号を見て重複しているデータを削除する</li>
</ul>
</li>
<li><em>flow control</em> を提供する

<ul>
<li>peer に対して何バイトのサイズのデータを受け入れられるか <em>(advertised window)</em> 伝える</li>
<li>送信者が受信バッファを超えるデータを送ることを防ぐ</li>
<li>送信者からデータを受信すると window サイズは小さくなり、受信アプリケーションがバッファからデータを読むと window サイズは大きくなる</li>
</ul>
</li>
<li>TCP コネクションは <em>full-duplex</em> である

<ul>
<li>アプリケーションはいつでもデータの送信と受信ができる</li>
<li>sequence number や window size の状態の経過を追い続ける</li>
</ul>
</li>
</ul>


<h2>Stream Control Transmission Protocol (SCTP)</h2>

<ul>
<li>クライアント・サーバ間の接続は connection ではなく、 <em>association</em> と呼ばれる

<ul>
<li>2システム間の通信が2つ以上のアドレスを使用することができる</li>
</ul>
</li>
<li><em>message-oriented</em> である

<ul>
<li>TCP は byte 指向</li>
</ul>
</li>
<li>接続間で複数のストリーム (multiple stream) を提供する

<ul>
<li>ストリームの1つに含まれる message が失われても、他のストリームの message の配信に影響しない</li>
</ul>
</li>
<li>マルチホーミング (multihoming) を提供する

<ul>
<li>1つの SCTP エンドポイントが複数の IP アドレスをサポートする</li>
<li>ネットワークの不安定さに対するロバスト性を向上させる</li>
</ul>
</li>
</ul>


<h2>Three-Way Handshake</h2>

<p>TCP connection を張るときには以下のような処理が行われる：</p>

<ol>
<li>サーバは <code>socket</code>, <code>bind</code>, <code>listen</code> を呼び、接続を受け入れる準備をする <em>(passive open)</em></li>
<li>クライアントは <code>connect</code> を呼び <em>active open</em> を発行する。
クライアント TCP は SYN (synchronize) segment を送信して、サーバにクライアントが送る予定のデータサイズを教える。</li>
<li>サーバはクライアントの SYN を受け入れ、ACK (acknowledge) と自分の SYN を送る。
SYN にはサーバが送る予定のデータサイズが含まれている。
サーバの SYN とクライアントの SYN に対する ACK は1つのセグメントで送られる。</li>
<li>クライアントはサーバの SYN を受け入れる (ACK)</li>
</ol>


<h2>TCP Connection Termination</h2>

<p>接続を切るときは以下のような処理で行われる：</p>

<ol>
<li>片方のアプリケーションが <code>close</code> を呼び <em>(active close)</em>、TCP は FIN segment を送る。</li>
<li>もう片方の TCP が FIN を受け入れる <em>(passive close)</em>。FIN は end-of-file としてアプリケーションに通知される。</li>
<li>しばらくして、end-of-file を受信したアプリケーションはソケットを <code>close</code> し、FIN を送る。</li>
<li>active close を行った側の TCP が FIN を受け入れる。</li>
</ol>


<p>2 から 3 の間で passive close を行った側から active close を行った側にデータが送られることがある <em>(half-close)</em>。</p>

<h2>TIME_WAIT State</h2>

<ul>
<li>active close を行った側が close を受け取ったあとのタイムアウト待ち状態

<ul>
<li>タイムアウト時間は MSL <em>(maximum segment lifetime)</em> の2倍 (2MSL)</li>
</ul>
</li>
<li>TCP のコネクションを確実に切断する

<ul>
<li>ルータの異常によりループが発生すると古いパケットが残り続ける</li>
<li>そこで TCP がパケットを再送すると、ループが解消されたときに重複してパケットが送られる</li>
</ul>
</li>
<li>古い重複したセグメントをネットワークから expire させる

<ul>
<li>コネクションを再接続するときに、古いパケットが残らないようにする</li>
</ul>
</li>
</ul>


<h2>Four-Way Handshake</h2>

<p>SCTP connection を張るときには以下のような処理が行われる：</p>

<ol>
<li>サーバは <code>socket</code>, <code>bind</code>, <code>listen</code> を呼び、passive open を行う</li>
<li>クライアントは <code>connect</code> を呼び、active open を行う。
これによりクライアントは IP のリスト、初期シーケンス番号、この association での全てのパケットを識別するためのタグ、
クライアントがリクエストするストリーム量、クライアントが受け入れることのできるストリーム量を含んだ INIT メッセージを送る。</li>
<li>サーバはクライアントの INIT を受け取り、 INIT-ACK メッセージを送る。
INIT-ACK には 2. で述べた INIT が持つ情報に加えて state cookie が含まれる。
state cookie にはサーバが association が正当であることを補償するための全ての状態が含まれている。</li>
<li>クライアントはサーバの state cookie を COOKIE-ECHO メッセージとして返す。</li>
<li>サーバは cookie が正しいことを確かめ、COOKIE-ACK メッセージを送り association を成立させる。</li>
</ol>


<p>four-way handshake は SCTP が DoS 攻撃を防ぐために用いられる。</p>

<h2>Association Terminate</h2>

<ul>
<li>SCTP では TCP とは違い half-closed は受け入れられず、片方が association を切断した時にはもう片方はデータの送信をやめなければならない。</li>
<li>SCTP では verification tags があるため、TIME_WAIT state は存在しない。</li>
</ul>


<h2>Port Numbers</h2>

<ul>
<li>UDP, SCTP, TCP はプロセスを区別するために 16-bit integer のポート番号を使用する。</li>
<li>ポート番号は以下の3つのレンジに分かれる

<ul>
<li><em>well-known ports</em>: 0 - 1023<br/>
IANA によって管理されているポート</li>
<li><em>registered ports</em>: 1024 - 49151<br/>
IANA によって管理はされていないが、使い方を決めているポート</li>
<li><em>dynamic (private) ports</em>: 49152 - 65535<br/>
IANA が管理していないポート。 <em>ephemeral ports</em> （transport protocol によってクライアントに割り当てられるポート）に使われる。</li>
</ul>
</li>
<li>接続先を決めるための2つの値である IP アドレスとポート番号の組は <em>socket</em> と呼ばれる</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Unix Network Programming Chapter 1]]></title>
    <link href="http://kentaktwo.github.com/blog/2012/04/29/unp-chapter-1/"/>
    <updated>2012-04-29T17:30:00+09:00</updated>
    <id>http://kentaktwo.github.com/blog/2012/04/29/unp-chapter-1</id>
    <content type="html"><![CDATA[<h1>Introduction</h1>

<!--more-->


<h2>Introduction</h2>

<ul>
<li><em>protocol</em> とは、プログラムが通信する際の約束事</li>
<li>クライアントとサーバはネットワークプロトコルで通信するが、ネットワークプロトコルは複数の層からなる</li>
</ul>


<pre>
Web Client: Application layer
|
TCP (Transmission Control Protocol): Transport layer
|
IP (Internet Protocol): Network layer
|
Ethernet: Datalink layer
</pre>


<ul>
<li>クライアントとサーバがユーザプロセスであっても、 TCP や IP は通常カーネル内のプロトコルスタックとして動く</li>
<li>client と server は <em>LAN (Local Area Network)</em> や <em>WAN (Wide Area Network)</em> でつながっている</li>
<li>router が WAN のブロックを形成している</li>
<li>最大の WAN は <em>Internet</em> と呼ばれる</li>
</ul>


<h2>Error Handling: Wrapper Functions</h2>

<ul>
<li>エラーが起きた時に終了させる事はよくあるので、<em>wrapper function</em> として定義すると良い
``` c
int
Socket(int family, int type, int protocol)
{
  int n;
  if ((n = socket(family, type, protocol)) &lt; 0)

<pre><code>  err_sys("socket error");
</code></pre>

<p>  return (n);
}
```</p></li>
<li><p>スレッド関数はエラーが起きても <code>errno</code> に値をセットしないため、自分で関数の戻り値を <code>errno</code> にセットする必要がある
<code>c
int n;
if ((n = pthread_mutex_lock(&amp;ndone_mutex)) != 0)
  errno = n, err_sys("pthread_mutex_lock error");
</code>
wrapper function を書くと見やすくなる
``` c
void
Pthread_mutex_lock(pthread_mutex_t *mptr)
{
  int n;</p>

<p>  if ((n = pthread_mutex_lock(mptr)) == 0)</p>

<pre><code>  return;
</code></pre>

<p>  errno = n;
  err_sys("pthread_mutex_lock error");
}
```</p></li>
</ul>


<h2>OSI Model</h2>

<p>ネットワークの階層の有名な定義にISO (International Organization for Standardization) の <em>OSI (Open Systems Interconnecton)</em> Model がある</p>

<pre>
  +--------------+    +--------------+
7 | application  |    |              |
  +--------------+    |              |
6 | presentation |    | application  |   user process
  +--------------+    |              |        ^
5 | session      |    |              |        |
  +==============+    +==============+   ============
4 | transport    |    | TCP |  | UDP |        |
  +--------------+    +--------------+        v
3 | network      |    |  IPv4, IPv6  |      kernel
  +--------------+    +--------------+
2 | datalink     |    | device       |
  +--------------+    | driver       |
1 | physical     |    | hardware     |
  +--------------+    +--------------+
</pre>


<h2>Test Networks and Hosts</h2>

<ul>
<li><code>netstat -i</code> でネットワークインターフェースの情報が見れる

<ul>
<li><code>-n</code> オプションをつけるとアドレスを名前ではなく数字で表示する</li>
<li>loopback interface は <code>lo</code>, Ethernet は <code>eth0</code> 等と表示される</li>
</ul>
</li>
<li><code>netstat -r</code> でルーティングテーブルを表示する</li>
<li><code>ifconfig &lt;interface name&gt;</code> でインターフェースの詳細を表示する</li>
</ul>


<h2>64-Bit Architectures</h2>

<ul>
<li>32-bit Unix system のプログラミングモデルは <em>ILP32</em> model と呼ばれる

<ul>
<li>I: integers</li>
<li>L: long integers</li>
<li>P: pointers</li>
<li>integer も long integer も 32-bit</li>
</ul>
</li>
<li>64-bit Unix system のプログラミングモデルは <em>LP64</em> model と呼ばれる

<ul>
<li>long integer と pointer のみが　64-bit であることを必要とする</li>
<li>他は 32-bit</li>
</ul>
</li>
<li><code>size_t</code> 型は 32-bit system では 32-bit だが、64-bit system では 64-bit である

<ul>
<li>socket address programming 等で <code>size_t</code> が出てくることがある</li>
<li>しかし 64-bit も必要ない</li>
<li>そのため 64-bit system でも 32-bit のままであるような <code>t_scalar_t</code> や <code>t_uscalar_t</code> がある</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
</feed>
